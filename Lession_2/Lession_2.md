## Q：给定一个数组arr和一个整数num，请把小于等于num的数放左边，大于num的数放右边。要求时间复杂度为**O(N)**，额外空间复杂度为**O(1)**。
> * 思路一：在数组两边分别设置两个指针，然后从左边指针找到一个比num大的数，从右边指针找一个不大于num的数，然后交换两个指针所指向的数字；结束条件是左边指针不小于右边指针（大于或者等于）。
> * 思路二：设置一个less指针，这个指针表示该指针之前的所有数都小于等于num，然后一一考察数组中的每一个数。如果当前数小于等于num，则将当前数与less指针的下一个数交换，然后less扩大一个位置。
> * [代码](source/Partition.h)

## Q：**荷兰国旗问题**：给定一个数组arr和一个整数num，把小于num的数放左边，等于num的数放中间，大于num的数放右边。
> * 在数组左右分别设置两个指针less和more，less左边所有数都小于num，more右边所有数都大于num。然后逐一考察数组中所有数。如果当前数小于num，则把它与less的下一个数交换，并且less扩大1，考察下一个数；如果当前数等于num，直接考察下一个数；如果当前数大于num，则将当前数与more的前一个数交换，并且继续考察当前数。
> * [代码](source/NetherlandsFlag.h)

## Q：快速排序
> * **经典快排**：选取数组固定位置的数值为划分数组的基准，将数组划分为小于等于区域和大于区域，保证小于等于区域和大于区域交界处的值一定为基准值；每次只排好一个数。
> * **荷兰国旗加速的经典快排**：选取数组固定位置的数值为划分数组的基准，将数组划分为小于区域、等于区域、大于区域。只将小于区域和大于区域递归排序。
> * 时间复杂度为**O(N*logN)**， 额外空间复杂度为**O(logN)**，额外空间复杂度用来记录划分点的位置。
> * [代码](source/QuickSort.h)
> * **经典快排的缺点**，与数据状态有关，如果数组基本有序，则算法时间复杂度退化为**O(N^2)**，额外空间复杂度退化为**O(N)**。
> * **随机快排**：用于划分数组的基准随机选择，然后划分数组，该算法的时间复杂度期望为**O(N*logN)**。[代码](source/RandomQuickSort.h)
> * 快速排序的**partition**过程的时间复杂度为**O(N)**，额外空间复杂度为**O(1)**。
- - -
## 将所有递归算法改写成非递归版本
- - -

## Q：堆排序
> * 满二叉树与完全二叉树
> * 当使用数组来存储完全二叉树时，**左孩子**为**2i+1**，**右孩子**为**2i+2**，每个结点的**父节点**为(**(i-1)/2**，**0**结点的父亲为自己（(0-1)/2）= 0。
> * **大根堆**与**小根堆**
>   > * 大根堆：大根堆是一个完全二叉树，并且任何一个子树的最大值都是子树的根节点；
>   > * 小根堆：小根堆是一个完全二叉树，并且任何一个子树的最小值都是子树的根节点；
> * 建立堆的复杂度：**O(N) = log1 + log2 + log3 + ...... + log(N-1)**
> * 将堆中元素向上调整的过程叫做`HeapInsert`，将堆中元素向下调整的过程为`Heapify`，这两个函数的复杂度均为**O(logN)**。
> * 堆排序：先将数组建立成一个堆结构（如果从小到大排序则建立大根堆，从大到小排序建立小根堆），然后逐一将堆顶与最后一个元素交换，减小堆的大小，再执行`Heapify`，直到堆的大小减为1。
> * 堆排序时间复杂度**O(N*logN)**，额外空间复杂度为**O(1)**。
> * [代码](source/HeapSort.h)
> * **优先队列底层就是堆结构**。