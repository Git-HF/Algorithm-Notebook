- - -
- 
- - -
## Q：用队列实现栈
> * 使用双队列。注意：在出队并入队时，最好不要使用queue.size()，因为queue.size()是随时变化的。[我的代码](Source/TwoQueueToStack.h)
> * 使用单队列；当入栈时，先将新元素入队列，然后将前n-1个元素先出队列，再入队列；[我的代码](Source/SingleQueueToStack.h)

## Q：48.旋转矩阵 <span id='48'></span>
> * [题目链接](https://leetcode-cn.com/problems/rotate-image/solution/`)
> * 如果可以使用额外空间，则很简单；从右边开始遍历每一列，并且把每一列当作旋转后的行；每一列之间的次序不变。时间复杂度和空间复杂度均为**O(N^2)**。
> * 不使用额外空间时，分层旋转；寻找每一层旋转90度后的规律。时间复杂度为**O(N^2)**，空间复杂度为**O(N)**。[我的代码](Source/RotateMatrix.h)
> * 只需要将矩阵先转置，然后沿竖直中心轴对折即可。交换两个数可以借助加法或者异或。（原理？？？）时间复杂度为**O(N^2)**，空间复杂度为**O(N)**。[代码](Source/RotateMatrix_1.h)
> * [返回](#48copy)
>   > ```
>   > 加法：  
>   > x = x + y;
>   > y = x - y;
>   > x = x - y;
>   > 异或：
>   > x = x ^ y;
>   > y = x ^ y;
>   > x = x ^ y;
>   > ```

## Q：对角线遍历
> * 主要就是确定对角线，使用两个标记，从左上角开始，一个向右走，走到右边界，则向下走；另一个往下走，走到下边界，则往右走。最终两个标记重合；一次打印两个标记对角线上的元素。**注意转折点的处理** [我的代码](Source/FindDiagonalOrder.h)
> * 在打印每一个对角线时，行+列总是一个固定的数；并且总对角线数量等于M+N-2。寻找行的起始位置和终止位置的规律，然后从起始到终止或者终止到起始进行打印即可。[我的代码](Source/FindDiagonalOrder_1.h)

## Q：排序矩阵查找
> * 从左下角或者右上角开始查找，时间复杂度**O(M+N)**，空间复杂度**O(1)**。[***代码***](Source/SearchMatrix.h)
> * 由于每一行都是有序的，可以对每一行执行二分查找，时间复杂度为**O(M*logN)**，空间复杂度为**O(1)**。[***代码***](Source/SeachMatrix_1.h)

## Q：21.合并两个有序链表 <span id="21"></span>
> * [题目链接](https://leetcode-cn.com/problems/merge-two-sorted-lists/)
> * 使用类似外排序的归并方法，时间复杂度**O(M+N)**，空间复杂度**O(1)**（这里不像数组的外排空间复杂度为O(M+N)）。[***代码***](Source/MergeTwoLists.h)
> * 自己新建链表头节点时，可以建立指向一个无用节点的头节点，这样可以避免对链表是否为空的讨论。
> * 递归算法。时间复杂度为**O(M+N)**，空间复杂度为**O(M+N)**。[***代码***](Source/MergeTwoLists.java)
> * [返回](#21copy)

## Q：234.回文链表 <span id = "234"></span>
> * 使用栈结构逆置链表，然后逐一比较，时间复杂度**O(N)**，空间复杂度**O(N)**。(**改进该算法，先利用快慢指针找到中间点，并且压栈；当快指针到达尾节点时，出栈，并且与慢指针比较。一遍出栈，慢指针一遍下移)[代码](Source/IsPalindrome.h)
> * 使用快慢指针，当快指针走到尾时，慢指针走到链表一半的地方。逆置后半部分，然后与前半部分比较。最后将链表返回原样。注意快指针边界处理问题。(**寻找链表的中间点也可以先遍历计算链表长度，然后走一半的长度**)[代码](Source/IsPalindrome_1.h)
> * 原地逆置指针可以使用**头插法**。
> * 将值复制到数组中，然后在数组中使用双指针法。时间复杂度**O(N)**，空间复杂度**O(N)**
> * 利用递归函数和一个全局变量(leetcode官方解答)。
> * 可以将链表前半部分翻转；[代码](Source/isPalindrome_2.h)
> * [返回](#234copy)

## Q：分割链表
> * 荷兰国旗问题简单版本，设置一个`less`指针指向链表头，遍历链表，如果比要求的数小，将当前数与`less`所指向的数交换，然后less指针后移。时间复杂度**O(N)**，空间复杂度**O(1)**[***代码***](Source/PartitionList.h)
> * 设置两个链表头，一个表示小于要求值，另一个表示大于等于要求值。遍历链表对号入座即可，最后将两个链表连接在一起，时间和空间复杂度与上面相同。[***代码***](Source/PartitionList_1.h)

## Q：复制带随机指针的链表
> * 利用map结构，关联节点复制前后的关系，然后一一遍历。时间复杂度**O(N)**，空间复杂度**O(N)**[***代码***](Source/CopyRandomList.h)
> * 复制每一个节点，并置于原结点后面，然后一一遍历。时间复杂度**O(N**，空间复杂度**O(1)**。**注意，在第二次遍历链表处理`random`指针时，不能直接将原链表与新链表分离，因为后续节点的`random`指针可能会指向前面，这样就找不到新链表的节点了。另外random指针可能为`NULL`，小心处理**。[***代码***](Source/CopyRandomList_1.h)
> * 由于每个链表有两个额外指针，所以将其看作是图，利用`hashmap`当作每个节点的标志位，从头节点开始回溯。如果当前节点不`hashmap`中，则直接返回该节点对应的复制节点；如果不在，则创建新节点，并且回溯设置`next`指针和`random`指针，然后返回。时间复杂度和空间复杂度均为**O(N)**[***代码***](Source/CopuRandomList_2.java)
> * 暴力解法，先按`next`指针复制好链表，然后复制`random`指针；计算`random`指针相对于头节点需要走多少步，然后复制的链表也走这么多步。时间复杂度**O(N^2)**，空间复杂度**O(1)**；[***代码***](Source/CopyRandomList_3.h)
> * 复制链表，然后将原链表的`random`指针指向新链表，新链表`random`指针指向原链表，这样只需要两次遍历就可以完成。时间复杂度**O(N)**，空间复杂度**O(1)**。(***当自己建立无用的头节点时，可以使用局部变量而不是指针，这样免去了释放内存的操作***)(该**方法错误**，如果后面节点的`random`指针指向前面的话，那么后面节点将找不到前面节点相对应的新节点。)

## Q：141.环形链表 <span id="141"></span>
> * [题目链接](https://leetcode-cn.com/problems/linked-list-cycle/)
> * 使用`set`存储访问过的节点，然后遍历链表。如果`set`重复访问了某一链表，有环；否则没有环。时间复杂度和空间复杂度均为**O(N)**。[**代码**](Source/HasCycle.h)
> * 利用快慢指针，如果有环，快慢指针必定会相遇。（注意：一开始`fast`等于`slow`，需要排除这种情况；或者可以将`fast`直接置成`head->next`，或者指针先走，然后判断）时间复杂度**O(N)**，空间复杂度**O(1)**。[**代码**](Source/HasCycle_1.h)。 [**代码**](Source/HasCycle_2.h)
> * [返回](#141copy)

## Q：160.(无环)相交链表 <span id="160"></span>
> * 遍历其中一个链表，并且将节点存储在`set`中。遍历第二个链表，判断在`set`中是否有相同元素；如果有，则相交；如果没有则不相交。时间复杂度和空间复杂度均为**O(M+N)**。[代码](Source/GetIntersectionNode.h)
> * 如果两个链表相交，那么尾节点必定相同。所以先查找尾节点，并且计算链表长度；让长链表走两个链表的差值，然后一起走。第一次碰到一起就是相交点。时间复杂度**O(M+N)**，空间复杂度**O(1)**。[代码](source/GetIntersectionNode_1.h)
> * 创建两个指针，分别遍历其中一个链表；并且到一个链表遍历结束时，遍历另一个链表。当他们第一次相等时(不是`NULL`)，则是相交点；如果遍历完两个链表还没有相等，则不相交。时间复杂度**O(M+N)**，空间复杂度**O(1)**。**该方法只能对于无环链表才能使用。**[代码](Source/GetIntersectionNode_2.h)
 > * [返回](#160copy)

- - -
## **非递归版本前序、中序、后序的区别：前序在入栈时输出，中序在出栈时输出，后序在第二次出栈时输出。(还有Morris遍历？？？)**
- - - 

## Q：144.二叉树前序遍历
> * [***递归版本代码***](Source/PreOrderTranveral.h)
> * 在对左右孩子进行压栈时，应该先压右孩子，再压左孩子。[***迭代版本代码***](Source/PreOrderTranveral_1.h)
> * 两种情况时间复杂度均为**O(N)**，空间复杂度取决于树的结构，最坏空间复杂度也为**O(N)**，平均情况下为**O(logN)**。

## Q：94.二叉树的中序遍历 <span id="94"></span>
> * [题目链接](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)
> * [***迭代版本代码***](Source/InOrderTranversal.h)
> * 复杂度问题与上面相同。
> * [返回](#94copy)

## Q：145.二叉树的后续遍历
> * 整体思路：利用一个指针来表示当前指针，如果不为空，则将当前节点压入`dataStack`，并且在`flagStack`中压入一个`false`，表示此节点未访问右节点；将当前节点左移。如果当前节点为空，则判断`flagStack`栈顶元素是否为`ture`。如果不是，说明还没访问`dataStack`栈顶元素的右孩子，所以将指针指向其右孩子，然后`flagStack`栈顶元素改为`true`；如果是，则将两个栈都出栈，输出当前元素，然后将当前元素置为空。[***迭代版本代码***](Source/PostOrderTranversal.h)
> * 由于后序遍历的顺序为**左右中**，是**中右左**的逆序，所以仿照前序遍历先遍历**中右左**，再逆序就好。[***代码***](Source/PostOrderTraversal_1.h)
> * 对于后序遍历来说，如果当前节点有右孩子，那么上一个输出的节点一定是右孩子；如果没有右孩子，那在访问完左节点后，可以直接输出自己，所以可以定义一个变量来记录上一次访问的节点即可判断当前的节点是否已经访问完左右孩子。[***代码***](Source/PostOrderTranversal_3.h)
> * 以上算法的时间复杂度和空间复杂度均为**O(N)**。


## Q：102.二叉树的层序遍历 <span id="102"></span>
> * 利用队列来存储每一层的节点，并且用两个变量来表示当前层还有几个节点和下一层有几个节点。注意这些变量的边界处理。[***代码_1***](Source/LevelOrder.h)[***代码_2***](Source/LevelOrder_1.h)
> * 以上两种方法实际上是**BFS**，可以利用递归函数进行**DFS**。[***代码***](Source/LevelOrder_2.h)
> * 利用两个队列，一个队列存储当前层节点，另一个队列存储当前层节点的子节点。两个队列循环利用。[***代码***](Source/LevelOrder_3.h) （该代码速度最快）
> * 以上三种算法时间复杂度均为**O(N)**。
> * [返回](#102copy)

## Q：后继者（找出二叉搜索树指定节点的下一个节点（中序后继）），如果不存在，就返回NULL。
> * 如果当前节点有右孩子，那么其后继节点为右子树的最左孩子；如果没有右孩子，那么其后继节点为以该子树为左子树的节点，如果这样的节点不存在，则说明它是最后一个节点，返回NULL。对于二叉搜索树查找每一个节点的父节点时间复杂度为**O(logN)**，最坏情况下需要查找**O(logN)** 个节点，所以时间复杂度为**O((logN)^2)**；空间复杂度**O(1)**。[***代码***](Source/InOrderSuccessor.h) [***代码***](Source/InOrderSuccessor_3.h)
> * 利用递归函数，如果当前节点大于等于根节点，则后继节点一定在根节点的右子树上；当前节点小于根节点，则后继节点可能为根节点，也可能在左子树中。时间复杂度为**O(logN)**， 空间复杂度为**O(logN)**，[***代码***](Source/InOrderSuccessor_4.h)
> * 由于查找中序遍历的后继，所以直接对二叉树进行中序遍历并保存序列。最后遍历中序序列，直接返回下一个就好。时间复杂度和空间复杂度均为**O(N)**。[***代码***](Source/InOrderSuccessor_1.h)
> * 利用中序遍历，在找到目标节点时，设置一个标志位，然后下一次出栈的节点即为要找的节点。时间复杂度为**O(N)**，空间复杂度**O(1)**。[***代码***](Source/InOrderSuccessor_2.h)
> * [题解连接](https://leetcode-cn.com/problems/successor-lcci/solution/zhong-xu-bian-li-de-xia-yi-ge-yuan-su-5da-jie-fa-h/)。

## Q：297.二叉树的序列化和反序列化
> * 最主要就是区分每个节点和有空孩子的节点，用一些特殊的字符来表示就可以了。
> * [前序遍历序列化和反序列化](Source/BinaryTreeSerialize.h) ------ [别人的代码](Source/BinaryTreeSerialize_1.h) 时间复杂度和空间复杂度均为**O(N)**。
> * 未实现层序遍历。

## Q：110.平衡二叉树。
> * 自底向上递归判断，时间复杂度和空间复杂度均为**O(N)**。[代码](Source/IsBalanceTree.h) ------ [leetcode官方代码](Source/IsBalanceTree_1.h) ------ 当需要返回两个参数时，可以使用`pair`类型。
> * 还可以自顶向下判断，但这样重复计算高度，时间复杂度为**O(N*logN)**，空间复杂为**O(N)**。

## Q：98.验证二叉搜索树。
> * [题目链接](https://leetcode-cn.com/problems/validate-binary-search-tree/)
> * 非递归中序遍历，记录前一项访问的节点。如果前一项节点大于等于当前节点，则直接返回不是二叉搜索树。时间复杂度和空间复杂度均为**O(N)**。[代码](Source/IsBST.h)
> * 递归版中序遍历，想清楚整个流程，注意`pre`指针的修改。注意初始条件的判断时间复杂度和空间复杂度均为**O(N)**。[代码](Source/IsBST_1.h)
> * 基于边界的递归。递归调用函数时，像函数传递节点的边界值，然后递归调用。时间复杂度和空间复杂度均为**O(N)**。**运行速度最快** 。该方法实质是前序递归[代码](Source/IsBST_2.h)

## Q：222.完全二叉树的节点个数
> * 迭代判断子树子树是否是完全二叉树。对于一个完全二叉树来说，其左子树和右子树至少有一个是满二叉树。对于满二叉树，用公式计算；对于另一个半完全二叉树迭代使用该方法。时间复杂度**O((logN)^2)**，空间复杂度**O(1)**。[代码](Source/CountNodes.h)
> * 思想与上面相同，但使用递归方法。时间复杂度**O((logN)^2)**，空间复杂度**O(logN)**。[代码](Source/CountNodes_1.h) [代码简洁版](Source/CountNodes_2.h)
> * 二分搜索最后一层，判断出最后一层有多少节点就可以了。[参考链接](https://leetcode-cn.com/problems/count-complete-tree-nodes/solution/wan-quan-er-cha-shu-de-jie-dian-ge-shu-by-leetcode/)
> * 

## Q：200.岛屿数量
> * [题目连接](https://leetcode-cn.com/problems/number-of-islands/)
> * 递归算法，DFS，将遍历过的岛屿都标记一下。时间复杂度**O(MN)**，最坏空间复杂度**O(MN)**。所有网格均为陆地。[我的代码](Source/NumIsLands.h) [官方代码](Source/NumIsLands_1.h)
> * 利用一个队列，实现一个BFS遍历，思想与上面一样。[官方代码](Source/NumIsLands_2.h)
> * 并查集方法 [其他人代码](Source/NumIsLands_3.h)

## Q：208.实现前缀树 <span id='208'></span>
> * [题目连接](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)
> * 前缀树又叫字典树，Trie树。每个边代表一个字符，通常情况下表示该结点是否是一个字符串的结尾，也可以根据需要扩展。[我的代码](Source/TrieTree.h)
> * [返回](#208copy)

## Q：502.IPO
> * [题目链接](https://leetcode-cn.com/problems/ipo/)
> * 贪心算法。总体思想就是找到目前我可以做的项目，并在其中选取获取利润最大的项目做。利用两个堆结构来找到可以做的项目和获取利润最大的可做项目。利用一个小根堆存储我目前还无法做的项目，按项目花费成本排序；利用大根堆存储我现在可以做的项目中，按利润大小排序。每做完一个项目，更新两个堆结构。[我的代码](Source/findMaximizedCapital.h)。该代码中，注意优先级队列的使用，特别是自定义结构中比较函数的定义。

## Q：78.子集（求一个字符串所有可能的子集） <span id="78"></span>
> * [题目链接](https://leetcode-cn.com/problems/subsets/)
> * 回溯算法。对于每一个元素，都可以添加或者不添加，所以递归处理下一个元素即可。时间复杂度为**O(N*2^N)**[分析链接](https://leetcode-cn.com/problems/subsets/solution/hui-su-si-xiang-tuan-mie-pai-lie-zu-he-zi-ji-wen-t/)，空间复杂度为**O(N)**。[我的代码](Source/subsets.h)
> * 对于这一题，递归的做法是，如果我已经知道N-1个元素的所有子集，那么对于所有子集，都可以选择添加或者不添加自己，然后递归处理。
> * leetcode官方解答中，利用一种位掩码的方法。先生成N位的位掩码，在位掩码中，相应位置为1，则表示选取这个数；否则不选取这个数。然后根据位掩码生成每个子集。[其他人代码](Source/subsets_1.java)
> * [返回](#78copy)

## Q：46.全排列（求一个字符串的全排列）<span id="46"> </span>
> * [题目连接](https://leetcode-cn.com/problems/permutations/)
> * 回溯算法，时间复杂度 **(N * N!)**，空间复杂度**O(N)**[我的代码](Source/Permute.h)。官方代码未使用标记数组，直接在原数组中修改[官方代码](Source/Permute_1.h)
> * STL函数中有一个next_permutation函数，可以求一个区间所有元素的全排列。**使用前需要先将数组排序**。参考 [31.下一个排列](#31) 
> * [返回](#46copy)


## Q：64.最小路径和 <span id="64"></span>
> * [题目连接](https://leetcode-cn.com/problems/minimum-path-sum/)
> * 暴力递归，对于任意一个结点，其路径只能向右或者向下；所以只需要递归求出下节点和右节点的最短路径，然后选取其中较小的，加上自己的值返回即可。时间复杂度**O(2^(M+N))**，因为每次路径选择有两种情况，总共要选择M+N次。空间复杂度**O(M+N)**。该方法测试超时。[我的代码](Source/minPathSum.h)
> * 在暴力递归的过程中，有很多子问题重复计算了，所以可以使用动态规划进行优化。时间和空间复杂度均为**O(M*N)**。（这是二维动态规划的过程。）[我的代码(利用递归函数的dp)](Source/minPathSum_1.h)。[我的代码(直接数组递推的dp)](Source/minPathSum_2.h)
> * 一维动态规划：由于每个元素的计算只需要下一行和后面一个元素，而最后一个元素的计算只需要下一行的最后元素。所以可以只利用一行的额外空间复杂度，然后从右向左开始计算。时间复杂度**O(M*N)**，空间复杂度**O(N)**。[官方代码](Source/minPathSum_3.java)
> * [返回](#64copy)

- - -
- - -
## 自己做的题目

## 84. 柱状图中最大矩形（网易雷火实习笔试题
> * 暴力求解。计算任意一对柱子之间的面积，挑选其中最大的。在每一对柱子之间，需要先计算这之间最矮的柱子。时间复杂度**O(N^3)**，空间复杂度**O(1)**。
> * 优化的暴力求解，对于每一个柱子的高度，向两边查找，直到数组结束或者有比他矮的柱子。然后计算这之间的面积。遍历整个数组，找到最大的面积。时间复杂度**O(N^2)**，空间复杂度**O(1)**。**测试超时**。[我的代码](Source/largestRectangleArea.h)
> * 分治的思想：在找到最矮的柱子时，最大面积可能存在一下几种情况：1）以最矮柱子一直向两边延伸；2）在最矮柱子的左边（子问题）；3）在最矮柱子的右边（子问题）；递归求解就好。平均时间复杂度**O(N*logN)**,但最坏情况下是**O(N^2)**，柱子的高度是单调递增或者单调递减的。空间复杂度为**O(N)**。**测试超时**。[我的代码](Source/largestRectangleArea_1.h)
> * 优化的分治：对于最矮柱子的查找，可以使用**线段树**来优化。以保证最坏情况下时间复杂度也为**O(N*LogN)** [代码连接](https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/28941/segment-tree-solution-just-another-idea-onlogn-solution)。
> * 什么是单调栈？
> > * 单调栈分为**单调递增栈**和**单调递减栈**。单调递增(递减)栈表示栈内元素保持递增(或者递减)
> * 操作规则：（单调递增栈为例）
> > * 如果新元素大于(广义的大于，可能是其它属性)栈顶元素，就入栈
> > * 如果新元素小于栈顶元素，把栈顶元素出栈，直到新元素大于栈顶元素。
> * 加入这种规则后的效果：
> > * 栈内元素是单调递增的
> > * 当元素出栈时，该元素在数组中，右边第一个小于它的数即为这个新元素；左边第一个小于它的数即为栈顶元素。
> * 单调栈：对于每一个柱子，如果以该柱子作为高，那么只需要找到它的左右边界即可。利用单调递增栈，可以快速找到每个元素的左右边界。[我的代码](Source/largestReactangleArea_2.h)。[其他人代码，设置哨兵](Source/largestReactangleArea_3.h)
> * [返回](#11copy)

## Q：31.下一个排列 <span id="31"> </span>  
> * 返回 [46.全排列](#46)
> * [题目链接](https://leetcode-cn.com/problems/next-permutation/)
> * 从数组尾部向前判断，直到遇到第一个打破递增状态的元素。将最后的这几个递增元素逆置，然后从中选取一个比打破递增状态元素大的最小的元素。让他们交换即可。注意边界的考虑。时间复杂度**O(N)**；空间复杂度**O(1)**。[我的代码](Source/nextPermutation.h) 利用了STL中的二分查找。[别人代码](Source/nextPermutation_1.h) 


- - -
- - -
## ------------------leetcode hot 100-----------------

## Q：617.合并二叉树
> * [题目链接](https://leetcode-cn.com/problems/merge-two-binary-trees/)
> * 根据题意，直接同时递归调用两个子树即可。然后处理一下一棵树到达叶子结点的异常情况。时间复杂度为**O(min(M, N))**，空间复杂度为**O(log min(M, N))**。[我的代码](Source/mergeTrees.h)；[其他人代码](Source/mergeTress_1.h)
> * 可以将递归版本修改为非递归版本。

## Q：461.汉明距离
> * [题目链接](https://leetcode-cn.com/problems/hamming-distance/)
> * 根据题意，即找两个数二进制形式相应位上数值不同的次数。先利用异或，然后统计异或结果中有多少个1即可。统计1的个数可以使用右移操作然后与1进行`&`操作。由于整数的位数是固定的，所以最多比较31次。所以时间和空间复杂度均为**O(1)**。[我的代码](Source/hammingDistance.h)
> * 布莱恩.克尼格根算法：当一个数N与N-1进行与操作时，那么最右边的一个1将会被消除。利用此方法，通过异或结果中1的个数。时间和空间复杂度均为**O(1)**。[我的代码](Source/hammingDistance_1.h)


## Q：226.翻转二叉树
> * [题目链接](https://leetcode-cn.com/problems/invert-binary-tree/)
> * 按照题意，将一棵二叉树先序遍历，另一个按“伪后序遍历”，则它们的遍历顺序是对称。这里的后序遍历指的是先遍历当前结点，然后遍历右子树，最后遍历左子树。一遍遍历，一遍建树即可。时间复杂度**O(N)**。空间复杂度**O(N + logN)**。logN是递归栈的深度。[我的代码](Source/invertTree.h)
> * 递归的思想：要想翻转整个二叉树，只需要递归翻转左子树和右子树，然后将左孩子和右孩子交换即可。时间复杂度为**O(N)**，空间复杂度为**O(logN)**。[我的代码](Source/invertTree_1.h)
> * 层序遍历，一种迭代的自顶向下的做法：对于根结点，先入队列；当出队列时，交换结点左右孩子，然后判断左右孩子是否为空，如果不为空则需要入队列。时间复杂度为**O(N)**。空间复杂度为**O(N)**，对于满二叉树，最后一层需要存储N/2个结点。[官方代码](Source/invertTree.java)

## Q：104.二叉树的最大深度
> * [题目链接](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)
> * 递归计算左右子树的高度，然后返回其中较大者加1。时间复杂度**O(N)**，空间复杂度**O(logN)**。[我的代码](Source/maxDepth.h)
> * 层序遍历，每一层即为一个高度。[我的代码](Source/maxDepth_1.h)；[其他人代码](Source/maxDepth_2.h)
> * 当使用迭代版本DFS时，可以使用pair结构，标识每个结点的深度。[其他人代码](Source/maxDepth_3.h)

## Q：206.反转链表
> * [题目链接](https://leetcode-cn.com/problems/reverse-linked-list/)
> * 如果可以使用 **O(N)** 的额外空间复杂度，则使用一个栈，先将所有结点入栈，然后出栈，一一连接就好。时间和空间复杂度均为**O(N)**。
> * 当使用递归反转链表时，递归函数返回已经返回已经反转过的链表的尾节点，然后重新连接一下当前结点和尾节点就好。为了最后返回反转的链表，需要定义一个全局变量，保存反转链表后的头节点。时间和空间复杂度均为**O(N)**。[我的代码](Source/reverseList.h)；[别人的代码](Source/reverseList.java)
> * 当使用迭代方法时，遍历链表，一遍遍历，一遍修改结点指针的指向。时间复杂度**O(N)**，空间复杂度为**O(1)**。[我的代码](Source/reverseList_1.h)
> * 遍历链表，依次将每个结点头插到新链表中。时间复杂度**O(N)**，空间复杂度**O(1)**。[其他人代码](Source/reverseList_2.h)

## Q：136.只出现一次的数字
> * [题目链接](https://leetcode-cn.com/problems/single-number/)
> * 由于只允许线性复杂度，所以想到使用hash，利用`hashset`来实现。由于大部分元素都出现两次，所以遍历数组，第一次遇到元素，将其加入`hashset`；第二次遇到再将其从中删除。这样一次遍历下来，`hashset`中只存在那个只出现一次的元素。然后再遍历一遍数组，判断哪个元素在`hashset`中即可。时间和空间复杂度均为**O(N)**。[我的代码](Source/singleNumber.h)
> * 位操作：任何一个整数，如果将它和0异或，那么将得到它自己；如果将其和自己异或，那么将得到0。并且异或操作满足交换律。所以将数组中所以元素异或，将得到那个只出现一次的元素。时间复杂度为**O(N)**，空间复杂度为**O(1)**。[我的代码](Source/singleNumber_1.h)

## Q：169.多数元素
> * [题目链接](https://leetcode-cn.com/problems/majority-element/)
> * 由于多数元素大于n/2，所以将数组排序后，最中间的元素一定是多数元素。排序使用快排，所以时间复杂度为**O(N*logN)**，空间复杂度为**O(logN)**。[我的代码](Source/majorityEliment.h)
> * 利用哈希表进行计数。最后遍历哈希表，找出其中次数大于N/2的元素。时间复杂度为**O(N)**，空间复杂度为**O(N)**。[官方代码](Source/majorityEliment_1.h)
> * 分治法：如果一个数是一个数组的众数，那么其一定也是数组左半部分或者右半部分的众数。所以递归求出左右子数组的众数，然后将其合并即可。时间复杂度为**O(NlogN)**，空间复杂度为**O(logN)**。[官方代码](Source/majorityEliment_2.h)
> * 摩尔投票法：用一个计数变量和候选变量，计数变量初始化为0，候选变量可以初始化为任意数。然后遍历数组。如果当前变量与候选变量相同，则递增计数变量，否则递减计数变量；如果计数变量为0，则将当前数赋值给候选变量，然后继续以上过程。当遍历完数组时，候选变量即为众数。时间复杂度为**O(N)**，空间复杂度为**O(1)**。[我的代码](Source/majorityElement_3.h)
> * **摩尔投票法的原理**：当一个数重复的次数超过数组长度的二分之一，那么将数组中任意两个不同的数删除后，最终剩下的数就是这个要找的数。
> * 位运算：对于数组上的所有数，因为众数的个数超过数组的二分之一，所以考虑所有整数的每个位上的值。统一所有整数上每个位是否为1。如果是，则最终的众数该位上也为1，否则最终的众数上该位不为1。时间复杂度为**O(N)**，空间复杂度为**O(1)**。[其他人代码](Source/majorityElement_4.h)

## Q：21.合并两个有序链表 <span id="21copy"></span>
> * [链接](#21)

## Q：538.把二叉搜索树转换为累加树
> * [题目链接](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)
> * **反序中序遍历**：对于一个二叉搜索树，右子树上所有结点值比它大，所以先递归处理右子树，然后计算右子树所有元素和，当前结点值加上右子树所有元素和；然后递归处理左子树。时间复杂度为**O(N)**，空间复杂度为**O(logN)**，最坏情况下空间复杂度为**O(N)**。[我的代码](Source/convertBST.h)
> * 利用**Morris遍历**，实现 **O(1)** 的空间复杂度。(自己实现一下)[官方代码](Source/convertBST.java)

## Q：283.移动零
> * [题目链接](https://leetcode-cn.com/problems/move-zeroes/)
> * 根据题意，遍历数组，如果当前元素为0，从下一个位置开始遍历，找到一个非0值与当前元素交换。如果找不到一个任意一个非0值，则说明符合题意了。时间复杂度为**O(N^2)**，空间复杂度为**O(1)**。[我的代码](Source/moveZeroes.h)
> * **双指针法**：对于上面的解决方法，每次查找非0值都是从当前元素的下一个元素查找的，这样做了很多重复的查找。因为从当前元素的下一个到上一次查找返回的第一个非0值之间肯定都是0值，所以为了提高查找效率，应该从上一次查找返回的位置开始查找。时间复杂度为**O(N)**，空间复杂度为**O(1)**。其实也是快排的思想。[我的代码](Source/moveZeroes_1.h)。[官方代码](Source/moveZeroes_2.h)

## Q：448.找到所有数组中消失的数字
> * [题目链接](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)
> * 由于题目要求 **O(N)** 的时间复杂度和**O(1)**的空间复杂度，所以需要在原数组上做标注。由于所有元素的值都在`1 - N`之间，并且数组长度为`N`，所以遍历数组，当元素值`value`不为`0`值，则先将位置`value-1`位置上的元素记录下来为`tmp`，然后将位置`value-1`上的元素置为`0`，以表示元素`value`出现过；递归处理位置`tmp`上的元素，直到位置`tmp`上的元素为`0`。[我的代码](Source/findDisappearedNumbers.h)
> * leetcode官方案例中，将相应位置置为负数，所以不需要递归处理，感觉简单一点。时间复杂度为**O(N)**，空间复杂度为**O(1)**。[官方代码](Source/findDisappearedNumbers_2.h)
> * 还可以将相应位置上的数+N做标记。
> * 将数值`i+1`放在`i`的位置，最后判断，如果位置`i`处放的不是`i+1`，则说明数组中没有这个数。时间复杂度为**O(N)**，空间复杂度为**O(1)**。[别人的代码](Source/findDisappearedNumbers_3.h)
> * 利用`hashset`，将所有元素都加入`hashset`，然后再从`1 - N`，判断`hashset`中是否存在该元素，如果不存在，则说明未出现。时间和空间复杂度均为**O(N)**。[我的代码](Source/findDisappearedNumbers_1.h)

## Q：437.路径总和 III
> * [题目链接](https://leetcode-cn.com/problems/path-sum-iii/)
> * **自己想法**：类似于求一个数组的所有子集，对于每一个结点，都可以要和不要，然后递归处理左子树和右子树。不过对于这里，当不选取结点时，后续结点总和应该是原始的和，而不是传递的参数。 **该方法不正确,因为有的结点会被重复计算。比如一个结点的左子树有两种情况，那么这两种情况可能会被两次叠加。第一次为选取该节点的父节点，不选取该节点；第二次为不选取父节点，也不选取该结点。这两种情况都会在父节点计算时被叠加。**。 [我的代码](Source/pathSum.h)
> * **前缀和**：对于每一个结点，可以记录遍历路径上的所有结点的前缀和。对于当前结点，如果存在前缀和为当前结点前缀和减去目标值，则存在一条路径。如果把`map`的查找操作看作是 **O(1)** 的时间复杂度，那么这个算法的时间复杂度为 **O(N)** ，空间复杂度为 **O(logN)** ，因为`map`的长度为树的高度。**注意需要提前在`map`中存储前缀和为`0`的项，不然无法计算单结点为目标值的情况。** [我的代码](Source/pathSum_1.h)
> * **双递归**：核心在于：需要遍历树中每一个结点，所以这是一层递归。对于遍历到的每一个结点，都要计算是否有以自己为起点的路径，这就是第二层递归。对于第一层遍历，可以使用任何递归、非递归或者层序遍历都可以。[别人的代码](Source/pathSum_2.h)
> * **单递归**：首先，还是要遍历整个树，遍历树中所有结点。对于遍历的路径，用一个vector来存储，表示当前结点的前面结点是哪些。然后计算以当前结点为终点结点的路径有几个。时间复杂度为**O(NlogN)**，空间复杂度为**O(logN)**。[别人的代码](Source/pathSum_3.h)

## Q：160.相交链表 <span id="160copy"></span>
> * [链接](#160)

## Q：121.买卖股票的最佳时机
> * [题目链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
> * 根据题意，找到每一元素前面最小的元素即可，如果没有，那自己就是最小的元素。在那一天买入，当前卖出。遍历数组，找到最大的利润。时间复杂度**O(N)**，空间复杂度**O(1)**。[我的代码](Source/maxProfit.h)
> * **单调栈**：对于单调增栈，每个栈元素出栈时，那么在它前面并且比他小的元素都栈中，所以出栈元素减去栈底元素即为在该元素卖出时可得的最大利润。为了最后将所有数据出栈，在数组末尾额外添加一个利润为0的哨兵。时间复杂度**O(N)**，空间复杂度**O(N)**。[我的代码](Source/maxProfit_1.h)
> * **动态规划**：如果使用`dp[i]`表示第i天的最大利润，那么有公式`dp[i]=max(dp[i−1],prices[i]−minprice)`。该方法其实和第一种方法类似。时间复杂度为**O(N)**，空间复杂度**O(N)**。[其他人代码](Source/maxProfit_2.h)
> * **区间和和求差问题的相互转换，必看**。[链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/121-mai-mai-gu-piao-de-zui-jia-shi-ji-dp-7-xing-ji/)

## Q：155.最小栈
> * [题目链接](https://leetcode-cn.com/problems/min-stack/)
> * 使用一个辅助栈，用来存储当插入或者删除一个数后，剩下元素的最小值；[代码](Source/MinStack.h)
> * 使用一个辅助数组，当插入一个数时，如果插入的数比不大于minStack栈顶元素，则向minStack插入新元素，否则不插入；当删除一个数时，如果删除的数与当前minStack的栈顶元素相等，则minStack也删除栈顶元素。[代码](Source/MinStack_1.h)
> * （**该方法有问题，当差值大于整数所能表示的范围，该方法错误**）压缩还原法：只需要一个栈stack、一个保存当前最小值的变量min和当前的top值；当入栈时，先将value-min入栈；如果value-min小于零，则更新min；否则不更新；最后更新top；当出栈时，先判断栈顶元素是否小于零。如果是，则更新min，否则不更新。栈中元素出栈。此时返回top值，并且更新top；如果此时栈顶元素小于零，则top=min；否则top=min+栈顶元素。

## Q：53.最大子序和
> * [题目链接](https://leetcode-cn.com/problems/maximum-subarray/)
> * **动态规划**：`dp[i]`代表以第`i`个元素结尾的连续子数组最大和，则有`dp[i]=max(dp[i−1] + num[i], num[i])`，该公式表名如果以上一个元素结尾的最大子序列和小于0，则当前元素应该从头算起。时间复杂度为**O(N)**，空间复杂度为**O(N)**。从状态转移方程中我们可以发现，以当前元素结尾的最大子序列只取决于以上一个元素结尾的最大子序列，所以可以将`dp`数组优化为一个数，使空间复杂度将为**O(1)**。[我的代码](Source/maxSbuArray.h)
> * **分治法**：对于一个数组，将其分为两半，那么其最大子序和只可能有三种情况：在左半部数组，在右半部数组，或者跨越左半部和右半部。所以递归求解左半部和右半部的最大子序和。当跨越左半部和右半部时，从中间开始向两边查找，先查找从中间开始的左半部最大值，再查找从中间开始的右半部最大值，然后将两个相加即得到跨越左半部和右半部的最大子序列和。然后与递归求得的结果比较，返回最大值。时间复杂度**O(NlogN)**，空间复杂度**O(logN)**。（注意归并排序空间复杂度为**O(N)**，因为外排的过程需要额外空间复杂度，而这里仅仅需要递归的深度）。[我的代码](Source/maxSubArray_1.h)
> * **官方分治法**：官方分治法返回较多数据，所以使合并子序列过程中时间复杂度变成**O(1)**，所以官方算法中时间复杂度为**O(N)**。[官方代码](Source/maxSubArray_2.h)。
> * 题外话
>   > * **分治法**较于**动态规划**来说，时间复杂度相同，但是因为使用了递归，并且维护了四个信息的结构体，运行的时间略长，空间复杂度也不如动态规划优秀，而且难以理解。那么这种方法存在的意义是什么呢？
>   > * 对于这道题而言，确实是如此的。但是仔细观察分治法，它不仅可以解决区间 [0, n - 1]，还可以用于解决任意的子区间 [l, r]的问题。如果我们把 [0, n - 1]分治下去出现的所有子区间的信息都用堆式存储的方式记忆化下来，即建成一颗真正的树之后，我们就可以在 **O(logN)** 的时间内求到任意区间内的答案，我们甚至可以修改序列中的值，做一些简单的维护，之后仍然可以在 **O(logn)** 的时间内求到任意区间内的答案，对于大规模查询的情况下，这种方法的优势便体现了出来。这棵树就是上文提及的一种神奇的数据结构——**线段树**。

## Q：101.对称二叉树
> * [题目链接](https://leetcode-cn.com/problems/symmetric-tree/)
> * **深度优先遍历**：将参数改为两个结点，表示左右对称的结点。先判断是否都为空，如果为空，则返回`true`；如果只有一个空，则返回`false`；如果两个都不为空，则判断值是否相等，并且递归判断他们的左右子节点是否相同。时间和最坏空间复杂度均为**O(N)**。[我的代码](Source/isSymmetric.h)。[其他人代码](Source/isSymmetric_2.h)
> * **层序遍历**：改变每个结点子节点的入队顺序，左边结点左节点入队，有边结点右节点入队，左边结点右节点入队，右边结点左节点入队，这样就能保证每次出队两个结点应该是相同的，否则不是对称二叉树。时间和空间复杂度均为**O(N)**。BFS方法需要注意对空结点的处理。[官方代码](Source/isSymmetric_1.java)

## Q：543.二叉树的直径
> * [题目链接](https://leetcode-cn.com/problemset/hot-100/)
> * **递归暴力**：感觉该题是求二叉树高度的变种。对于任意一个结点，以该节点为根节点的二叉树直径就是左子树高度+右子树高度+2；所以递归求解左右子树即可，并且在递归求解过程中记录最大直径。时间复杂度为**O(N)**，平均空间复杂度**O(logN)**。[我的代码](Source/diameterOfBinaryTree.h)。[别人的代码](Source/diameterOfBinaryTree_1.h)

## Q：70.爬楼梯
> * [题目链接](https://leetcode-cn.com/problems/climbing-stairs/)
> * **动态规划**：时间和空间复杂度均为**O(N)**。由于每个点的状态只取决于前两个状态，所以可以将空间复杂度压缩为**O(1)**。[我的代码](Source/climbStairs.h)
> * **暴力递归**：模拟爬楼梯的过程，对于任何一个台阶，下一步都可以走一步或者走两步。然后递归求解，直到到达所需要的高度。时间复杂度为**O(2^N)**，因为在整个递归树中，最大的深度为N，最小的深度为N/2。空间复杂度为**O(N)**，递归树的最大深度为N。[官方代码](Source/climbStairs_1.java)
> * **优化的暴力递归**：在暴力递归的过程中，很多步骤都重复计算了，可以利用一个数组，记录下已经计算过的路径，当数据中相应数据有值时，直接返回就好。时间复杂度和空间复杂度均为**O(N)**。[官方代码](Source/climbStairs_2.java)
> * **斐波那契数列公式**：时间复杂度为**O(logN)**，**因为计算一个数的N次方的代价是O(logN)。**空间复杂度为**O(1)**。[官方链接](https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode/)
> * **计算一个数N次方的时间复杂度为O(logN)，记住方法**。
> * **排列组合方法**：到达第N层台阶，可以分成以下情况：每次只走一步，只有一种情况；只有一次走了两步，有**C(n-1, 1)**；只有两次走了两步，有**C(n-2, 2)**; ...... 一直到，走了N/2次两步，有**C(N/2, N/2)**。所以把所有情况相加就可以了。时间复杂度为**O(N)**，空间复杂度**O(1)**。[官方代码](Source/climbingStairs_3.h)

## Q：两数之和
> * [题目链接](https://leetcode-cn.com/problems/two-sum/)
> * **暴力求解**：任意两个整数之和，判断是否等于目标值。时间复杂度为**O(N^2)**，空间复杂度**O(1)**。[我的代码](Source/twoSum.h)
> * **先排序**：先对原数组排序，然后利用双指针。主要时间和空间复杂度来自于排序。**此方法错误，因为题目需要返回他们的数组下标，在排序时将数组下标打乱了。如果需要返回元素，此方法可以**。
> * **利用C++中`multimap`的排序功能**：先将所有所有元素都加入`multimap`中，然后使用双指针从头尾开始向中间遍历。这里必须使用`multimap`，不能是`map`，因为可能有重复元素；也不能是`unorderedmap`，它不提供排序功能。注意`multimap`不支持索引访问元素，只能使用迭代器。**注意multimap**的用法。[我的代码](Source/twoSum_2.h)
> * **hashmap**：在`hashmap`中，存储每个元素及其下标。当遍历每一个元素时，判断`hashmap`中是否存在`target - current`的元素。如果存在，直接返回。时间复杂度为**O(N)**，空间复杂度为**O(N)**。[我的代码](Source/twoSum_1.h)

## Q：141.环形链表 <span id="141copy"></span>
> * [链接](#141)

## Q：198.打家劫舍
> * [题目链接](https://leetcode-cn.com/problems/house-robber/)
> * **暴力递归**：对于第`i`个位置的最大值，有两种情况：1）第`i`个元素加上第`i+2`位置的最大值；2）等于第`i+1`位置上的最大值。时间复杂度为**O(N^2)**，空间复杂度为**O(N)**。**该方法超时。**[我的代码](Source/rob.h)
> * **动态规划**：上面的暴力递归过程中，有很多重复计算，可以改成动态规划。时间和空间复杂度均为**O(N)**。空间复杂度可以优化到**O(1)**。[我的代码](Source/rob_1.h)

## Q：234.回文链表 <span id="234copy"></span>
> * [链接](#234)

## Q：20.有效的括号
> * [题目链接](https://leetcode-cn.com/problems/valid-parentheses/)
> * **栈辅助结构**：如果为左括号则入栈；如果为右括号则出栈；中途出现任何问题都视为不满足要求。时间和空间复杂度均为**O(N)**。[我的代码](Source/isValid.h)。[其他人代码](Source/isValid_1.h)
> * 原题中是三种类型的括号，如果只有一种类型的括号，可以利用计数器即可，而不用使用栈结构。如果遇到左括号计数器加一，如果遇到右括号计数器减一。空间复杂度只需要**O(1)**。

## Q：581.最短无序连续子数组
> * [题目链接](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)
> * 先将数组排序好，然后统计前后各有多少数组相同，中间的数即为最短的子数组。时间复杂度主要为数组排序的时间复杂度，空间复杂度为**O(N)**，因为需要遍历数组排序前后的差距。[我的代码](Source/findUnsortedSubarray.h)。[官方代码](Source/findUnsortedSubarray_3.java)
> * **暴力**：即遍历每一个连续子数组，计算出子数组的最小值`min`和最大值`max`，然后是否子数组左边部分全小于最小值`min`，并且右边部分全大于最大值`max`。找出最短的子数组即可。时间复杂度为**O(N^3)**，空间复杂度为**O(1)**。[官方代码](Source/findUnsortedSubarray_1.java)
> * 对于每一个元素`i`，判断其右边是否有比它小的元素；如果存在元素`j`比`i`小，说明最短子数组的范围左边界应该小于等于`i`，右边界应该大于`j`。判断所有元素即可。时间复杂度为**O(N^2)**，空间复杂度为**O(1)**。[官方代码](Source/findUnsortedSubarray_2.java)
> * **栈**：看官方说明。[官方链接](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/solution/zui-duan-wu-xu-lian-xu-zi-shu-zu-by-leetcode/)
> * **不使用额外空间复杂度**：该方法思想是从栈方法中转变过来的。数组左边开始遍历，从第一个不是升序的元素开始，找到最小元素`min`，然后计算其真正的位置，这就是最短无序连续子数组的左边界。同理可找到右边界。时间复杂度为**O(N)**，空间复杂度为**O(1)**。[官方代码](Source/findUnsortedSubarray_4.java)
> * 其他人的方法。[链接](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/solution/shi-jian-chao-guo-100de-javajie-fa-by-zackqf/)

## Q：78.子集 <span id="78copy"></span>
> * [链接](#78)

## Q：46.全排列 <span id="46copy"></span>
> * [链接](#46)

## Q：22.括号生成
> * [题目链接](https://leetcode-cn.com/problems/generate-parentheses/)
> * **回溯算法**：对于同一种括号的字符串，可以利用一个整数就能判断其是否是有效括号组合。所以利用一个整数`current_left`，表示当前剩余未匹配左括号个数。如果`current_left`等于0，则只能添加1右括号，否则左右括号都能添加。再利用两个整数`leftn`和`rightn`分别表示还有多少左括号或者右括号未添加即可。~~时间复杂度为**O(2^N)**~~，官方答案说时间复杂度为第N个卡特兰数。空间复杂度为**O(N)**。[我的代码](Source/generateParenthesis.h)。[别人代码](Source/generateParenthesis_1.h)。[别人非递归版本代码](Source/generateParenthesis_4.h)
> * **广度优先算法**：[链接](https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/)
> * **动态规划**：`dp[i]`表示`i`个括号可以生成的有效括号对数。那么已知前`i-1`个括号的所有情形时，对于新添加一个括号，那么在这一对新括号中间可能有`0`个括号，`1`个括号......`i-1`个括号，而这些子问题都是已知的。[我的代码](Source/generateParenthesis_2.h)。[别人的代码](Source/generateParenthesis_3.h)
> * **构造法**：[链接](https://leetcode-cn.com/problems/generate-parentheses/solution/gou-zao-fa-jian-dan-cu-bao-de-si-lu-by-ma-xing/)

## Q：338.比特位计数
> * [题目链接](https://leetcode-cn.com/problems/counting-bits/)
> * **暴力方法**：对于每个数，右移32位，然后记录其中1的个数。时间复杂度为**O(N)**。虽然空间复杂度为**O(N)**，但是需要进行**N*sizeof(int)** 次。空间复杂度为**O(1)**。[我的代码](Source/countBits.h)
> * **动态规划**：用`f(num)`表示数字`num`二进制中包含1的位的个数。对于数字`num`，如果知道了其处于`2^n-1`和`2^n`之间，那么`f(num) = f(num - 2^N-1) + 1`。所以利用两个整数，表示`num`的上下边界即可。时间复杂度为**O(N)**，只需要一次遍历。**空间复杂度**为**O(N)**。[我的代码](Source/countBits_1.h)
> * **动态规划+最后位置位**：对于任意正数`x`，`x & (x - 1)`可以将最后一位1置为0，所以`x`与`x & (x - 1)`相比，只是多了一位1，所以可得转移方程`f(x) = f( x & (x - 1)) + 1`。时间复杂度为**O(N)**，空间复杂度为**O(1)**。[官方代码](Source/countBits.java)
> * **简单思路**：对于自然数，任意一个奇数都比前面那个偶数多一个1，因为多的就是最低位的1。任意一个偶数都和它的一半拥有相同个数的1，因为除以2相当于右移，所以1的个数不变。时间复杂度为**O(N)**，空间复杂度为**O(1)**。[其他人代码](Source/countBits_2.h)。[其他人代码](Source/countBits_3.h)

## Q：94.二叉树中序遍历 <span id="94copy"></span>
> * [链接](#94)

## Q：114.二叉树展开为链表
> * [题目链接](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)
> * **非迭代先序遍历**：按照非迭代先序遍历，在遍历过程中修改节点的左右指针即可。时间复杂度为**O(N)**，最坏空间复杂度为**O(N)**。[我的代码](Source/flatten.h)
> * 分成三步：将左子树插入到右子树的地方；将原来的右子树接到左子树的最右边节点；考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null。时间复杂度为**O(N)**，非迭代版本最坏时间复杂度为**O(N)**，迭代版本时间复杂度为**O(1)**。[我的代码](Source/flatten_1.h)。[官方代码](Source/flatten_2.java)
> * **简单递归思路**：分成三步：首先将左子树变成链表；然后将右子树变成链表；然后将右子树连接在左子树的尾部，然后将左子树变成右子树即可。[其他人代码](Source/flatten_3.java)

## Q：238.除自身以外数组的乘积
> * [题目链接](https://leetcode-cn.com/problems/product-of-array-except-self/)
> * **前缀思想**：如果可以使用除法，则将所有元素相乘，然后除以自己即可，时间和空间复杂度都不高。利用前缀和的思想，利用两个额外数组，分别存储前缀积和后缀积，然后将两个数组对应位置元素相乘即为答案。时间和空间复杂度均为**O(N)**。[我的代码](Source/productExceptSel.h)
> * 官方解答中，利用输出数组来存储前缀积，然后动态构造后缀积，时间复杂度为**O(N)**，空间复杂度为**O(1)**。[官方代码](Source/productExceptSelf_1.h)
> * **上三角，下三角**：[链接](https://leetcode-cn.com/problems/product-of-array-except-self/solution/product-of-array-except-self-shang-san-jiao-xia-sa/)
> * **双指针**：利用双指针，同时两边计算乘积，本质上和上一个解答是一样的。时间复杂度为**O(N)**，空间复杂度为**O(1)**。[其他人代码](Source/productExceptSelf_2.h)

## Q：39.组合总和
> * [题目链接](https://leetcode-cn.com/problems/combination-sum/)
> * **暴力递归**：当成全排列来做，对于候选数组，每一个位置上的元素都可以要或者不要。从第一候选元素开始判断。当不选取某个元素，那么这个元素在以后就不能选取了，这个就相当于死锁的时候按一定顺序加锁，这里按照一定的顺序获取元素。[我的代码](Source/combinationSum.h)。[官方代码](Source/combinationSum_1.h)。**其实我的代码和官方代码原理是一样的，但是感觉不需要排序**
> * **贪心方法**：未完全理解。[链接](https://leetcode-cn.com/problems/combination-sum/solution/ctan-xin-suan-fa-qiu-jie-zhi-xing-0ms-by-lcl-17/)
> * **剩下看题解**。

## Q：48.旋转图像 <span id='48copy'></span>
> * [链接](#48)

## Q：208.实现前缀树 <span id='208copy'></span>
> * [链接](#208)

## Q：105.从前序与中序遍历序列构造二叉树
> * [题目链接](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
> * **递归**：根据先序遍历，在中序遍历中确定左子树和右子树的序列。然后递归建立二叉树。时间复杂度为**O(N^2)**，（注意这里不是O(N)，因为每次在中序遍历中查找根节点也需要时间，可以利用hash表，提前将元素值映射为索引值，这样可以将时间复杂度缩短为**O(N)**）空间复杂度为**O(logN)**。[我的代码](Source/buildTree.h)
> * **迭代法**：官方解答中给了一个迭代法，但是没看懂。[链接](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/)
> * [其他人的非递归解法](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/di-gui-gou-jian-by-yanyufang/)

## Q：96. 不同的二叉搜索树
> * [题目链接](https://leetcode-cn.com/problems/unique-binary-search-trees/)
> * **暴力递归**：**1-n**的所有二叉搜索树的个数等于以1为根节点个数 **+** 以2为根节点个数 **+** ...... **+** 以N为根节点的个数。然后对于每一个子问题再用递归方法解。时间复杂度为**O(N!)**。空间复杂度为**O(N)**。该算法超时。[我的代码](Source/numTrees.h)
> * **动态规划**：针对上面的方法，其实二叉搜索树的个数与具体的元素值无关，之于有序序列中，以第几个元素为根节点有关。例如对于序列1，2，3和4，5，6，以1为根节点的搜索树数量与以4为根节点的搜索树数量相同。加入f(n, i)表示在n个有序元素中，以第i个元素为根节点的搜索树数量，则有`f(n, i) = f(n, n-i)`。所以可以用此方法进行优化。时间复杂度为**O(N^2)**，空间复杂度为**O(N^2)**。（空间复杂度好像可以降到**O(N)**）[我的代码](Source/numTrees_1.h)
> * **官方解答**：官方解答中的动态规划比我的要简洁多了。[链接](https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode/)

## Q：148. 排序链表
> * [题目链接](https://leetcode-cn.com/problems/sort-list/)
> * 题目要求 **O(N*logN)** 的时间复杂度，就想到了归并。利用快慢指针进行分割链表。但是需要递归调用，空间复杂度为**O(logN)**。[我的代码](Source/sortList.h)
> * 对于归并排序来说，实际上就是相邻的2个元素比较，4个元素比较，8个元素比较，直到超过整个数组的长度。所以根据该原理，可以将时间复杂度将为**O(1)**。(**注意自己实现，实现起来较麻烦。**)[我的代码](Source/sortList_1.h)。(在链表之类的题目中，注意切断链表；同时使用dummyHead来统一化处理)。

## Q：64.最小路径和 <span id="64copy"></span>
> * [链接](#64)

# Q：287. 寻找重复数
> * [题目链接](https://leetcode-cn.com/problems/find-the-duplicate-number/)
> * 题目给了数组元素的范围大小，如果可以修改原数组元素，则可以将对应的元素放置到对应的位置即可。时间复杂度为**O(N)**，空间复杂度为**O(1)**。[我的代码](Source/findDuplicate.h)
> * 对于任意一个位置的元素，与后面的元素比较。时间复杂度为**O(N^2)**，空间复杂度为**O(1)**。[我的代码](Source/findDuplicate_1.h)
> * **二分查找**：二分法可以确定一个有范围的整数。利用抽屉原理，查找这个重复的数字的范围，并不断缩小，直到找到了这个数。时间复杂度为**O(NlogN)**，空间复杂度为**O(1)**。[我的代码](Source/findDuplicate_2.h)。**由于该题限制了只有一个重复的数，所以可以使用抽屉原理。**

## Q：406. 根据身高重建队列
> * [题目链接](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)
> * 根据题意，应该先排好身高较高的人，因为后续排的人身高都低于自己，对自己左边身高高于自己的人数没有印象。所以先将原数组排序，然后根据自己左边有几个人高于自己进行插入即可。空间复杂度主要取决于排序函数。排序的时间复杂度为**O(NlogN)**，将每个人进行插入的时间复杂度为**O(N^2)**，所以总体时间复杂度为**O(N^2)**。[我的代码](Source/reconstructQueue.h)

## Q： 215. 数组中的第K个最大元素
> * [题目链接](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)
> * **基于快排的快速选择**：利用快排中的partition思想，每次可以确定一个数排序后的位置。如果要找的数在这个数的左边，则对左边进行partition，否则对右边进行partition。时间复杂度的期望为**O(N)**，空间复杂度为**O(1)**，因为我用的是非递归方法，递归方法的空间复杂度为**O(logN)**。注意对索引K的变换，因为第K大实际上是第N-K+1大；或者改变partition的左右方向，左边放大数，右边放小数。[我的代码](Source/findKthLargest_1.h)
> * **堆结构**：利用最大堆，第K次出堆的数即为第K大的数。空间复杂度均为**O(N)**，时间复杂度为**O(NlogN)**，(建堆的时间复杂度为 **O(N)**，删除的总代价是O(klogn)，渐进时间复杂度为 **O(n+klogN) = O(NlogN)** )。[我的代码](Source/findKthLargest.h)
> * **直接排序**：时间复杂度为**O(NlogN)**，空间复杂度为**O(logN)**。[我的代码](Source/findKthLargest_2.h)
> * **主席树**:未看懂。[链接](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/ke-neng-shi-di-yi-ge-yong-zhu-xi-shu-cao-de-by-zer/)
> * **自己实现的堆排序**：[我的代码](Source/findKthLargest_3.h)

## Q：236. 二叉树的最近公共祖先
> * [题目链接](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)
> * 题目需要找出最近的公共祖先，那第一步，怎么找出某个节点的所有祖先。回想后续遍历，当遍历到某个结点时，此时栈中所有节点都是当前节点的祖先。又因为所有节点的祖先都是从根节点开始的，所以从第一个祖先开始，顺次遍历，直到找到最后一个两个节点拥有相同的祖先。找到某个节点的所有祖先时间复杂度为**O(N)**，然后找到最后一个相同的祖先时间复杂度也为**O(logN)**，所以总体时间复杂度为**O(N)**；平均空间复杂度为**O(logN)**，最坏空间复杂度为**O(N)**。[我的代码](Source/lowestCommonAncestor.h)
> * **递归**：定义`f(left)`为节点`x`的左子树包含p或者q节点；定义`f(right)`为节点`x`的右子树包含p或者q节点。所以符合条件的公共祖先一定满足`f(left) && f(right) || ((x == p || x == q) && (f(left) || f(right))))`。如果自底向上找，第一个满足条件的节点即为最近公共祖先。时间复杂度为**O(N)**，最坏空间复杂度为**O(N)**。[我的代码](Source/lowestCommonAncestor_1.h)。[更加简洁的代码](Source/lowestCommonAncestor_2.h)
> * **看不懂的算法**：[链接](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/di-gui-chi-xian-suan-fa-tarjanshi-yong-bing-cha-ji/)

## Q: 739. 每日温度
> * [题目链接](https://leetcode-cn.com/problems/daily-temperatures/)
> * 根据题意，即要找出每个数右边第一个比他大的数据。经典的单调栈应用场景，可以快速找出一个数两边第一个比他大或者比他小的数。时间复杂度位**O(N)**，空间复杂度为**O(N)**。[我的代码](Source/dailyTemperatures.h)
> * **暴力**：由于题目限制了温度的范围，所以可以建立一个`next`数组，用来记录从右边开始，第一个达到该温度的是在哪个位置。然后对于任意位置的温度，只需要判断`next`数组中是否有相应的比他高的温度即可。时间复杂度为**O(MN)**，空间复杂度为温度范围**O(M)**。
> * **从后向前遍历，有点动态规划的感觉**：建立`next`数组用来保存结果。最后一个元素所对应的值，一定是0。从倒数第二个值来说，如果当前元素小于后一个元素，则其值为1。否则`next[i+1]`相对应位置的元素比较。直到结尾为0或者找到比他大的数。[别人的代码](Source/dailyTemperatures.java)

## Q: 11. 盛水最多的容器 
> * [题目链接](https://leetcode-cn.com/problems/container-with-most-water/)
> * **暴力方法**:计算任意两根柱子之前可以接多少雨水，记录最大值。时间复杂度为**O(N^2)**，空间复杂度为**O(1)**。
> * **双指针法**：初始化时将`left、right`，分别指向数组的头和尾。那么对于任意一个状态，要想面积增大，那么只有较矮的那个指针往中间移动才可能找到更大的面积。因为宽度在减小，只能高度增加。而移动高的指针没有效果，所以只能移动矮的指针。时间复杂度为**O(N)**，空间复杂度为**O(1)**。[我的代码](Source/maxArea.h)。[正确性证明链接](https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/)。[比较好的题解](https://leetcode-cn.com/problems/container-with-most-water/solution/on-shuang-zhi-zhen-jie-fa-li-jie-zheng-que-xing-tu/)。

## Q： 102. 二叉树的层序遍历 <span id="102copy"></span>
> * [链接](#102)

## Q：49. 字母异位词分词
> * [题目链接](https://leetcode-cn.com/problems/group-anagrams/)
> * 该题第一任务就是怎么判断字母异位词。首先想到对字符串排序，如果排序后字符串相等，则它们是字母异位词。第二个任务是，怎么存储。一开始想法是直接存进结果数组里，然后对于以后的每个字符串，与数组中每组比较。如果相同，则加入这个组；如果不相同，则新建组。该方法时间复杂度太高。官方解答中使用`map`暂存，这样可以减少查找的时间复杂度。最终时间复杂度为**O(NKlogK)**。[我的代码](Source/groupAnagrams.h)。注意`map`的`key`使用排序后的string。[别人的代码，map中的value使用结果数组中的索引]
> * **按计数分类**：对于字母异位词，主要就是需要将字符串转化成某种形式，然后比较它们是否相同。可以统计每个字符出现的次数，然后将其序列化，作为比较是否相同的形式。这样可以降低时间复杂度。时间复杂度为**O(NK)**。[我的代码](Source/groupAnagrams_1.h)。虽然该方法的时间复杂度较低，但是增加了字符串的长度，增加了计算hash值的时间复杂度，所以真正的时间不一定比上一个方法快。时间证明要比上一个方法慢。另一种方法是将每个字符对应一个质数，最后计算乘积之和作为map的key，因为计算数字的hashcode比较快速。

## Q：647. 回文子串
> * [题目链接](https://leetcode-cn.com/problems/palindromic-substrings/)
> * **动态规划**:如果已经知道了前`n-1`个字符中回文子串的个数`f(n-1)`，那么加入第`n`个字符后，只需要计算以该字符为结尾的字符串有多少个回文子串，然后加上之前`f(n-1)`。判断某个字符串是否为回文子串可以利用双指针法。查找字符串的时间复杂度为**O(N^2)**，判断一个字符串是否为回文子串时间复杂夫为**O(N)**。空间复杂度为**O(1)**。[我的代码](Source/countSubstrings.h)
> * **从中心向两侧延伸**：对于一个长度为N的字符串，回文子串的中心位置的可能有2N-1个：单独的字符或者两个字符中间。所以从每个中心位置，向两边延申，判断是否为回文子串。时间复杂度为**O(N^2)**，空间复杂度为**O(1)**。[我的代码](Source/countSubstrings_1.h)
> * **马拉车算法**：未看懂。[题解](https://leetcode-cn.com/problems/palindromic-substrings/solution/hui-wen-zi-chuan-by-leetcode/)
> * **二维动态规划**：设`f(i, j)`表示从索引`i`到`j`位置的字符串是否为回文子串，那么有：1）如果`s[i]==s[j]`，则有`f(i, j) == f(i+1, j-1)`；2）如果`s[i] != s[j]`，则`f(i, j) = False`。并且对于`j = i + 1 && s[i] == s[j]`，则有`f(i, j) == True`。时间复杂度为**O(N^2)**，空间复杂度为**O(N^2)**。[我的代码](Source/countSubstrings_2.h)。注意填充dp数组的顺序不能错。

## Q：62. 不同路径
> * [题目链接](https://leetcode-cn.com/problems/unique-paths/)
> * **二维动态规划**：经典动态规划题目。时间复杂度和空间复杂度为**O(M*N)**。[我的代码](Source/uniquePath.h)
> * **一维动态规划**：时间复杂度为**O(M*N)**，空间复杂度为**O(N)**。[我的代码](Source/uniquePaths_1.h)
> * **数学方法**：如果机器人向右走表示1，向下走表示2，则最终机器人的路径可以用一串1，2组合来表示，可以利用排列组合来做。**注意计算排列组合的时候小心溢出**。

## Q：347. 前K个高频元素
> * [题目链接](https://leetcode-cn.com/problems/top-k-frequent-elements/)
> * **map + 堆排序**：对于统计数组中元素的频次，由于题目没有说明元素大小的范围，所以不能使用桶排序，只能利用`map`来统计元素频次；求前K大元素，使用堆结构，可以筛出前K大的元素，时间复杂度为**O(NlogK)**，小于**O(NlogN)**。[我的代码](Source/topKFrequent.h)。注意优先队列的使用，其参数类型和cmp对象。
> * **map +桶排序**：先使用`map`进行频次统计。第二步等于是对频次的大小进行排序。由于频次最小值为0,最大值为N，是一个有范围的整数排序，所以可以利用桶排序。总体时间复杂度为**O(N)**，空间复杂度为**O(N)**。[我的代码](Source/topKFrequent_1.h)
> * **map+快排**：先使用`map`进行频次统计。再利用快排partition的思想。如果能找到第K大的数，那么在该数右边的所有数就是所有数。期望时间复杂度为**O(N)**。[其他人代码](Source/topKFrequent_2.h)

## Q：337. 打家劫舍III
> * [题目链接](https://leetcode-cn.com/problems/house-robber-iii/)
> * **动态规划**：对于任意一个结点，从该子树可以盗取最高金额取决于自己下一层和下下一层所有结点可以盗取的最多金额。设`f(n)`表示从最后一层到第n层最多可以盗取的金额，则`f(n) = max(f(n-1), f(n-2) + 当前结点的数值)`，时间复杂度为遍历所有结点，为**O(N)**；空间复杂度为树递归的深度**O(logN)**。[我的代码](Source/rob_III_1.h)
> * **利用map的动态规划**：对于任意一个节点，其可以偷盗的最多的钱为**四个孙子+自己的钱 VS 两个儿子偷的钱**。当使用暴力递归自顶向下进行计算时，重复计算了很多子问题。由于是树结构，所以不能使用数组来存储，只能使用map来存储，避免重复计算。时间复杂度为**O(N)**，空间复杂度为**O(N)**。[我的代码](Source/rob_III_2.h)

## Q：279. 完全平方数
> * [题目链接](https://leetcode-cn.com/problems/perfect-squares/)
> * **map + 暴力**：对于任意一个数，计算其所有可能的组合，并记录个数最小的时候。为了减少重复计算，利用map存储。[我的代码](Source/numSquares.h)。[其他人代码(非递归)](Source/numSquares_1.h)。**使用递归超时，非递归方法不超时**。
> * **贪心+递归**：[代码解释](https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode/)。[我的代码](Source/numSquares_2.h)
> * **贪心+BFS**：（第一种方法相当于是一个DFS，遍历了整颗树）。对于数字`N`，总共有`sqrt(N)`种情况。如果把它想象在树中，即有`sqrt(N)`个分支。所以题目相当于求子树中值为`0`的节点，并且该节点离根节点最近。所以可以使用`BFS`。[代码解释](https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode/)
> * **DFS+剪枝**：[其他人代码](Source/numSquares_3.h)

## Q：309. 买卖股票的最佳时机含冷冻期
> * [题目链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
> * **动态规划(状态机思想)**：对于任意一天，其总共有三种状态：1）当前持有一只股票；2）不持有股票，但处于冷冻期；3）不持有股票，不处于冷冻期，可以购入当前的股票。根据该关系，可以列出状态转移方程。时间复杂度为**O(N)**，空间复杂度为**O(N)**。[我的代码](Source/maxProfit_II_1.h)。注意初始状态的定义。

## Q：75. 颜色分类
> * [题目链接](https://leetcode-cn.com/problems/sort-colors/)
> * **双指针**：荷兰国旗问题，将数组分为三部分。时间复杂度为**O(N)**，空间复杂度为**O(1)**。[我的代码](Source/sortColors.h)

## Q：17. 电话号码的字母组合
> * [题目链接](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)
> * 根据题意，即求N个集合的笛卡尔乘积。由于一开始不知道N的个数，所以无法直接使用N层循环。利用层层迭代的过程，先计算两个集合的笛卡尔积，一直迭代直到计算了所有集合。时间复杂度即为所有集合个数的乘积，如果将集合个数设定为K，则为**O(K^N)**。空间复杂度为**O(1)**。[我的代码](Source/letterCombinations.h)。该方法其实是**BFS**。
> * **递归回溯，其实是DFS**：有点像给定一个string，求其所有的子集。时间复杂度为**O(K^N)**，空间复杂度为**O(N)**，递归的深度。[官方代码](Source/letterCombinations_1.java)

## Q：394. 字符串解码
> * [题目链接](https://leetcode-cn.com/problems/decode-string/)
> * 对于这种存在括号嵌套的，典型的用栈来做，当遇到`']'`时，出栈，解括号。由于题目已经说了确保表达式的正确性，所以不用进行表达式是否合理的判断。时间复杂度为**O(N)**，空间复杂度为栈的空间**O(N)**。[我的代码](Source/decodeString.h)。[将字符串栈和数字栈分开](Source/decodeString_1.h)。[更加整洁的代码](Source/decodeString_2.h)。[别人的代码](Source/decodeString_3.h)
> * **递归方法**：[链接](https://leetcode-cn.com/problems/decode-string/solution/zi-fu-chuan-jie-ma-by-leetcode-solution/)。**没看懂**。

## Q：207. 课程表
> * [题目链接](https://leetcode-cn.com/problems/course-schedule/)
> * **拓扑排序DFS**：一开始直接用一个数组来标识课程`i`是否可以被学习`course[i]`，如果`course[i]`为-1，则可以学习；否则表示它依赖另一门课程，然后递归判断就好。但是提交后发现有的课程同时依赖多门课程，所以将数组类型表示成`vector<vector<int>>`，当`course[i].size()`大于1时，则表示同时依赖多门课程，然后一一判断。该方法时间复杂度为**O(N)**。**该算法的执行效果很差，时间和空间都很差**。[我的代码](Source/canFinish.h)。注意迭代器的使用。该问题其实是一个拓扑排序问题。[官方代码](Source/canFinish_1.h)。该题所形成的图是一个有向无权图。
> * **拓扑排序BFS**：先建立所有节点的邻接表。用一个队列来存储入度为0的节点，然后更新其他节点的入度数量。时间复杂度为**O(M+N)**，空间复杂度为**O(M+N)**。[我的代码](Source/canFinish_2.h)

## Q：621. 任务调度器
> * [题目链接](https://leetcode-cn.com/problems/task-scheduler/)
> * **贪心+排序**：由于在时间N之内，执行的任务不能相同，所以可以将N次执行任务看为一轮，那么在不同的轮次之间就可以执行任意任务。在每一轮中，从次数最多的任务中选取，这样可以防止同一个任务被积压。[我的代码](Source/leastInterval.h)。[官方代码](Source/leastInterval_2.java)
> * **优先队列**：和上面一样也是N次作为一轮，但是利用优先队列，可以避免多次排序，或者说排序时只需要对部分元素进行排序。[我的代码](Source/leastInterval_1.h)