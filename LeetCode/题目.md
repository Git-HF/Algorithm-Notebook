- - -
- 
- - -
## Q：用队列实现栈
> * 使用双队列。注意：在出队并入队时，最好不要使用queue.size()，因为queue.size()是随时变化的。[***代码***](Source/TwoQueueToStack.h)
> * 使用单队列；当入栈时，先将新元素入队列，然后将前n-1个元素先出队列，再入队列；[***代码***](Source/SingleQueueToStack.h)

## Q：旋转矩阵
> * 如果可以使用额外空间，则很简单；从右边开始遍历每一列，并且把每一列当作旋转后的行；每一列之间的次序不变；
> * 不使用额外空间时，分层旋转；寻找每一层旋转90度后的规律。[***代码***](Source/RotateMatrix.h)
> * 只需要将矩阵先转置，然后沿竖直中心轴对折即可。交换两个数可以借助加法或者异或。（原理？？？）[***代码***](Source/RotateMatrix_1.h)
>   > ```
>   > 加法：  
>   > x = x + y;
>   > y = x - y;
>   > x = x - y;
>   > 异或：
>   > x = x ^ y;
>   > y = x ^ y;
>   > x = x ^ y;
>   > ```

## Q：对角线遍历
> * 主要就是确定对角线，使用两个标记，从左上角开始，一个向右走，走到右边界，则向下走；另一个往下走，走到下边界，则往右走。最终两个标记重合；一次打印两个标记对角线上的元素。**注意转折点的处理** [***代码***](Source/FindDiagonalOrder.h)
> * 在打印每一个对角线时，行+列总是一个固定的数；并且总对角线数量等于M+N-2。寻找行的起始位置和终止位置的规律，然后从起始到终止或者终止到起始进行打印即可。[***代码***](Source/FindDiagonalOrder_1.h)

## Q：排序矩阵查找
> * 从左下角或者右上角开始查找，时间复杂度**O(M+N)**，空间复杂度**O(1)**。[***代码***](Source/SearchMatrix.h)
> * 由于每一行都是有序的，可以对每一行执行二分查找，时间复杂度为**O(M*logN)**，空间复杂度为**O(1)**。[***代码***](Source/SeachMatrix_1.h)

## Q：21.合并两个有序链表 <span id="21"></span>
> * [题目链接](https://leetcode-cn.com/problems/merge-two-sorted-lists/)
> * 使用类似外排序的归并方法，时间复杂度**O(M+N)**，空间复杂度**O(1)**（这里不像数组的外排空间复杂度为O(M+N)）。[***代码***](Source/MergeTwoLists.h)
> * 自己新建链表头节点时，可以建立指向一个无用节点的头节点，这样可以避免对链表是否为空的讨论。
> * 递归算法。时间复杂度为**O(M+N)**，空间复杂度为**O(M+N)**。[***代码***](Source/MergeTwoLists.java)
> * [返回](#21copy)

## Q：回文链表
> * 使用栈结构逆置链表，然后逐一比较，时间复杂度**O(N)**，空间复杂度**O(N)**。(**改进该算法，先利用快慢指针找到中间点，并且压栈；当快指针到达尾节点时，出栈，并且与慢指针比较。一遍出栈，慢指针一遍下移)[***代码***](Source/IsPalindrome.h)
> * 使用快慢指针，当快指针走到尾时，慢指针走到链表一半的地方。逆置后半部分，然后与前半部分比较。最后将链表返回原样。注意快指针边界处理问题。(**寻找链表的中间点也可以先遍历计算链表长度，然后走一半的长度**)[***代码***](Source/IsPalindrome_1.h)
> * 原地逆置指针可以使用**头插法**。
> * 将值复制到数组中，然后在数组中使用双指针法。时间复杂度**O(N)**，空间复杂度**O(N)**
> * 利用递归函数和一个全局变量(leetcode官方解答)。
> * 可以将链表前半部分翻转；[***代码***](Source/isPalindrome_2.h)

## Q：分割链表
> * 荷兰国旗问题简单版本，设置一个`less`指针指向链表头，遍历链表，如果比要求的数小，将当前数与`less`所指向的数交换，然后less指针后移。时间复杂度**O(N)**，空间复杂度**O(1)**[***代码***](Source/PartitionList.h)
> * 设置两个链表头，一个表示小于要求值，另一个表示大于等于要求值。遍历链表对号入座即可，最后将两个链表连接在一起，时间和空间复杂度与上面相同。[***代码***](Source/PartitionList_1.h)

## Q：复制带随机指针的链表
> * 利用map结构，关联节点复制前后的关系，然后一一遍历。时间复杂度**O(N)**，空间复杂度**O(N)**[***代码***](Source/CopyRandomList.h)
> * 复制每一个节点，并置于原结点后面，然后一一遍历。时间复杂度**O(N**，空间复杂度**O(1)**。**注意，在第二次遍历链表处理`random`指针时，不能直接将原链表与新链表分离，因为后续节点的`random`指针可能会指向前面，这样就找不到新链表的节点了。另外random指针可能为`NULL`，小心处理**。[***代码***](Source/CopyRandomList_1.h)
> * 由于每个链表有两个额外指针，所以将其看作是图，利用`hashmap`当作每个节点的标志位，从头节点开始回溯。如果当前节点不`hashmap`中，则直接返回该节点对应的复制节点；如果不在，则创建新节点，并且回溯设置`next`指针和`random`指针，然后返回。时间复杂度和空间复杂度均为**O(N)**[***代码***](Source/CopuRandomList_2.java)
> * 暴力解法，先按`next`指针复制好链表，然后复制`random`指针；计算`random`指针相对于头节点需要走多少步，然后复制的链表也走这么多步。时间复杂度**O(N^2)**，空间复杂度**O(1)**；[***代码***](Source/CopyRandomList_3.h)
> * 复制链表，然后将原链表的`random`指针指向新链表，新链表`random`指针指向原链表，这样只需要两次遍历就可以完成。时间复杂度**O(N)**，空间复杂度**O(1)**。(***当自己建立无用的头节点时，可以使用局部变量而不是指针，这样免去了释放内存的操作***)(该**方法错误**，如果后面节点的`random`指针指向前面的话，那么后面节点将找不到前面节点相对应的新节点。)

## Q：141.环形链表
> * 使用`set`存储访问过的节点，然后遍历链表。如果`set`重复访问了某一链表，有环；否则没有环。时间复杂度和空间复杂度均为**O(N)**。[***代码***](Source/HasCycle.h)
> * 利用快慢指针，如果有环，快慢指针必定会相遇。（注意：一开始`fast`等于`slow`，需要排除这种情况；或者可以将`fast`直接置成`head->next`，或者指针先走，然后判断）时间复杂度**O(N)**，空间复杂度**O(1)**。[***代码***](Source/HasCycle_1.h) [***代码***](Source/HasCycle_2.h)

## Q：160.(无环)相交链表
> * 遍历其中一个链表，并且将节点存储在`set`中。遍历第二个链表，判断在`set`中是否有相同元素；如果有，则相交；如果没有则不相交。时间复杂度和空间复杂度均为**O(M+N)**。[***代码***](Source/GetIntersectionNode.h)
> * 如果两个链表相交，那么尾节点必定相同。所以先查找尾节点，并且计算链表长度；让长链表走两个链表的差值，然后一起走。第一次碰到一起就是相交点。时间复杂度**O(M+N)**，空间复杂度**O(1)**。[***代码***](source/GetIntersectionNode_1.h)
> * 创建两个指针，分别遍历其中一个链表；并且到一个链表遍历结束时，遍历另一个链表。当他们第一次相等时(不是`NULL`)，则是相交点；如果遍历完两个链表还没有相等，则不相交。时间复杂度**O(M+N)**，空间复杂度**O(1)**。[***代码***](Source/GetIntersectionNode_2.h)
 
- - -
## **非递归版本前序、中序、后序的区别：前序在入栈时输出，中序在出栈时输出，后序在第二次出栈时输出。(还有Morris遍历？？？)**
- - - 
## Q：144.二叉树前序遍历
> * [***递归版本代码***](Source/PreOrderTranveral.h)
> * 在对左右孩子进行压栈时，应该先压右孩子，再压左孩子。[***迭代版本代码***](Source/PreOrderTranveral_1.h)
> * 两种情况时间复杂度均为**O(N)**，空间复杂度取决于树的结构，最坏空间复杂度也为**O(N)**，平均情况下为**O(logN)**。

## Q：94.二叉树的中序遍历
> * [***迭代版本代码***](Source/InOrderTranversal.h)
> * 复杂度问题与上面相同。

## Q：145.二叉树的后续遍历
> * 整体思路：利用一个指针来表示当前指针，如果不为空，则将当前节点压入`dataStack`，并且在`flagStack`中压入一个`false`，表示此节点未访问右节点；将当前节点左移。如果当前节点为空，则判断`flagStack`栈顶元素是否为`ture`。如果不是，说明还没访问`dataStack`栈顶元素的右孩子，所以将指针指向其右孩子，然后`flagStack`栈顶元素改为`true`；如果是，则将两个栈都出栈，输出当前元素，然后将当前元素置为空。[***迭代版本代码***](Source/PostOrderTranversal.h)
> * 由于后序遍历的顺序为**左右中**，是**中右左**的逆序，所以仿照前序遍历先遍历**中右左**，再逆序就好。[***代码***](Source/PostOrderTraversal_1.h)
> * 对于后序遍历来说，如果当前节点有右孩子，那么上一个输出的节点一定是右孩子；如果没有右孩子，那在访问完左节点后，可以直接输出自己，所以可以定义一个变量来记录上一次访问的节点即可判断当前的节点是否已经访问完左右孩子。[***代码***](Source/PostOrderTranversal_3.h)
> * 以上算法的时间复杂度和空间复杂度均为**O(N)**。


[跳转](#12345)
## Q：102.二叉树的层序遍历
> * 利用队列来存储每一层的节点，并且用两个变量来表示当前层还有几个节点和下一层有几个节点。注意这些变量的边界处理。[***代码_1***](Source/LevelOrder.h)[***代码_2***](Source/LevelOrder_1.h)
> * 以上两种方法实际上是**BFS**，可以利用递归函数进行**DFS**。[***代码***](Source/LevelOrder_2.h)
> * 利用两个队列，一个队列存储当前层节点，另一个队列存储当前层节点的子节点。两个队列循环利用。[***代码***](Source/LevelOrder_3.h) （该代码速度最快）
> * 以上三种算法时间复杂度均为**O(N)**。

## Q：后继者（找出二叉搜索树指定节点的下一个节点（中序后继）），如果不存在，就返回NULL。
> * 如果当前节点有右孩子，那么其后继节点为右子树的最左孩子；如果没有右孩子，那么其后继节点为以该子树为左子树的节点，如果这样的节点不存在，则说明它是最后一个节点，返回NULL。对于二叉搜索树查找每一个节点的父节点时间复杂度为**O(logN)**，最坏情况下需要查找**O(logN)** 个节点，所以时间复杂度为**O((logN)^2)**；空间复杂度**O(1)**。[***代码***](Source/InOrderSuccessor.h) [***代码***](Source/InOrderSuccessor_3.h)
> * 利用递归函数，如果当前节点大于等于根节点，则后继节点一定在根节点的右子树上；当前节点小于根节点，则后继节点可能为根节点，也可能在左子树中。时间复杂度为**O(logN)**， 空间复杂度为**O(logN)**，[***代码***](Source/InOrderSuccessor_4.h)
> * 由于查找中序遍历的后继，所以直接对二叉树进行中序遍历并保存序列。最后遍历中序序列，直接返回下一个就好。时间复杂度和空间复杂度均为**O(N)**。[***代码***](Source/InOrderSuccessor_1.h)
> * 利用中序遍历，在找到目标节点时，设置一个标志位，然后下一次出栈的节点即为要找的节点。时间复杂度为**O(N)**，空间复杂度**O(1)**。[***代码***](Source/InOrderSuccessor_2.h)
> * [题解连接](https://leetcode-cn.com/problems/successor-lcci/solution/zhong-xu-bian-li-de-xia-yi-ge-yuan-su-5da-jie-fa-h/)。

## Q：297.二叉树的序列化和反序列化
> * 最主要就是区分每个节点和有空孩子的节点，用一些特殊的字符来表示就可以了。
> * [前序遍历序列化和反序列化](Source/BinaryTreeSerialize.h) ------ [别人的代码](Source/BinaryTreeSerialize_1.h) 时间复杂度和空间复杂度均为**O(N)**。
> * 未实现层序遍历。

## Q：110.平衡二叉树。
> * 自底向上递归判断，时间复杂度和空间复杂度均为**O(N)**。[代码](Source/IsBalanceTree.h) ------ [leetcode官方代码](Source/IsBalanceTree_1.h) ------ 当需要返回两个参数时，可以使用`pair`类型。
> * 还可以自顶向下判断，但这样重复计算高度，时间复杂度为**O(N*logN)**，空间复杂为**O(N)**。

## Q：98.验证二叉搜索树。
> * 非递归中序遍历，记录前一项访问的节点。如果前一项节点大于等于当前节点，则直接返回不是二叉搜索树。时间复杂度和空间复杂度均为**O(N)**。[代码](Source/IsBST.h)
> * 递归版中序遍历，想清楚整个流程，注意`pre`指针的修改。注意初始条件的判断时间复杂度和空间复杂度均为**O(N)**。[代码](Source/IsBST_1.h)
> * 基于边界的递归。递归调用函数时，像函数传递节点的边界值，然后递归调用。时间复杂度和空间复杂度均为**O(N)**。**运行速度最快** 。该方法实质是前序递归[代码](Source/IsBST_2.h)

## Q：222.完全二叉树的节点个数
> * 迭代判断子树子树是否是完全二叉树。对于一个完全二叉树来说，其左子树和右子树至少有一个是满二叉树。对于满二叉树，用公式计算；对于另一个半完全二叉树迭代使用该方法。时间复杂度**O((logN)^2)**，空间复杂度**O(1)**。[代码](Source/CountNodes.h)
> * 思想与上面相同，但使用递归方法。时间复杂度**O((logN)^2)**，空间复杂度**O(logN)**。[代码](Source/CountNodes_1.h) [代码简洁版](Source/CountNodes_2.h)
> * 二分搜索最后一层，判断出最后一层有多少节点就可以了。[参考链接](https://leetcode-cn.com/problems/count-complete-tree-nodes/solution/wan-quan-er-cha-shu-de-jie-dian-ge-shu-by-leetcode/)
> * 

## Q：200.岛屿数量
> * [题目连接](https://leetcode-cn.com/problems/number-of-islands/)
> * 递归算法，DFS，将遍历过的岛屿都标记一下。时间复杂度**O(MN)**，最坏空间复杂度**O(MN)**。所有网格均为陆地。[我的代码](Source/NumIsLands.h) [官方代码](Source/NumIsLands_1.h)
> * 利用一个队列，实现一个BFS遍历，思想与上面一样。[官方代码](Source/NumIsLands_2.h)
> * 并查集方法 [其他人代码](Source/NumIsLands_3.h)

## Q：208.实现前缀树
> * [题目连接](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)
> * 前缀树又叫字典树，Trie树。每个边代表一个字符，通常情况下表示该结点是否是一个字符串的结尾，也可以根据需要扩展。[我的代码](Source/TrieTree.h)

## Q：502.IPO
> * [题目链接](https://leetcode-cn.com/problems/ipo/)
> * 贪心算法。总体思想就是找到目前我可以做的项目，并在其中选取获取利润最大的项目做。利用两个堆结构来找到可以做的项目和获取利润最大的可做项目。利用一个小根堆存储我目前还无法做的项目，按项目花费成本排序；利用大根堆存储我现在可以做的项目中，按利润大小排序。每做完一个项目，更新两个堆结构。[我的代码](Source/findMaximizedCapital.h)。该代码中，注意优先级队列的使用，特别是自定义结构中比较函数的定义。

## Q：78.子集（求一个字符串所有可能的子集）
> * [题目链接](https://leetcode-cn.com/problems/subsets/)
> * 回溯算法。对于每一个元素，都可以添加或者不添加，所以递归处理下一个元素即可。时间复杂度为**O(N*2^N)**[分析链接](https://leetcode-cn.com/problems/subsets/solution/hui-su-si-xiang-tuan-mie-pai-lie-zu-he-zi-ji-wen-t/)，空间复杂度为**O(N)**。[我的代码](Source/subsets.h)
> * 对于这一题，递归的做法是，如果我已经知道N-1个元素的所有子集，那么对于所有子集，都可以选择添加或者不添加自己，然后递归处理。
> * leetcode官方解答中，利用一种位掩码的方法。先生成N位的位掩码，在位掩码中，相应位置为1，则表示选取这个数；否则不选取这个数。然后根据位掩码生成每个子集。[其他人代码](Source/subsets_1.java)

## Q：46.全排列（求一个字符串的全排列）<span id="46"> </span>
> * [题目连接](https://leetcode-cn.com/problems/permutations/)
> * 回溯算法，时间复杂度 **(N * N!)**，空间复杂度**O(N)**[我的代码](Source/Permute.h)。官方代码未使用标记数组，直接在原数组中修改[官方代码](Source/Permute_1.h)
> * STL函数中有一个next_permutation函数，可以求一个区间所有元素的全排列。**使用前需要先将数组排序**。参考 [31.下一个排列](#31) 


## Q：64.最小路径和
> * [题目连接](https://leetcode-cn.com/problems/minimum-path-sum/)
> * 暴力递归，对于任意一个结点，其路径只能向右或者向下；所以只需要递归求出下节点和右节点的最短路径，然后选取其中较小的，加上自己的值返回即可。时间复杂度**O(2^(M+N))**，因为每次路径选择有两种情况，总共要选择M+N次。空间复杂度**O(M+N)**。该方法测试超时。[我的代码](Source/minPathSum.h)
> * 在暴力递归的过程中，有很多子问题重复计算了，所以可以使用动态规划进行优化。时间和空间复杂度均为**O(M*N)**。（这是二维动态规划的过程。）[我的代码(利用递归函数的dp)](Source/minPathSum_1.h)。[我的代码(直接数组递推的dp)](Source/minPathSum_2.h)
> * 一维动态规划：由于每个元素的计算只需要下一行和后面一个元素，而最后一个元素的计算只需要下一行的最后元素。所以可以只利用一行的额外空间复杂度，然后从右向左开始计算。时间复杂度**O(M*N)**，空间复杂度**O(N)**。[官方代码](Source/minPathSum_3.java)

- - -
- - -
## 自己做的题目

## 84. 柱状图中最大矩形（网易雷火实习笔试题）
> * 暴力求解。计算任意一对柱子之间的面积，挑选其中最大的。在每一对柱子之间，需要先计算这之间最矮的柱子。时间复杂度**O(N^3)**，空间复杂度**O(1)**。
> * 优化的暴力求解，对于每一个柱子的高度，向两边查找，直到数组结束或者有比他矮的柱子。然后计算这之间的面积。遍历整个数组，找到最大的面积。时间复杂度**O(N^2)**，空间复杂度**O(1)**。**测试超时**。[我的代码](Source/largestRectangleArea.h)
> * 分治的思想：在找到最矮的柱子时，最大面积可能存在一下几种情况：1）以最矮柱子一直向两边延伸；2）在最矮柱子的左边（子问题）；3）在最矮柱子的右边（子问题）；递归求解就好。平均时间复杂度**O(N*logN)**,但最坏情况下是**O(N^2)**，柱子的高度是单调递增或者单调递减的。空间复杂度为**O(N)**。**测试超时**。[我的代码](Source/largestRectangleArea_1.h)
> * 优化的分治：对于最矮柱子的查找，可以使用**线段树**来优化。以保证最坏情况下时间复杂度也为**O(N*LogN)** [代码连接](https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/28941/segment-tree-solution-just-another-idea-onlogn-solution)。
> * 什么是单调栈？
> > * 单调栈分为**单调递增栈**和**单调递减栈**。单调递增(递减)栈表示栈内元素保持递增(或者递减)
> * 操作规则：（单调递增栈为例）
> > * 如果新元素大于(广义的大于，可能是其它属性)栈顶元素，就入栈
> > * 如果新元素小于栈顶元素，把栈顶元素出栈，直到新元素大于栈顶元素。
> * 加入这种规则后的效果：
> > * 栈内元素是单调递增的
> > * 当元素出栈时，该元素在数组中，右边第一个小于它的数即为这个新元素；左边第一个小于它的数即为栈顶元素。
> * 单调栈：对于每一个柱子，如果以该柱子作为高，那么只需要找到它的左右边界即可。利用单调递增栈，可以快速找到每个元素的左右边界。[我的代码](Source/largestReactangleArea_2.h)。[其他人代码，设置哨兵](Source/largestReactangleArea_3.h)

## Q：31.下一个排列 <span id="31"> </span>  
> * 返回 [46.全排列](#46)
> * [题目链接](https://leetcode-cn.com/problems/next-permutation/)
> * 从数组尾部向前判断，直到遇到第一个打破递增状态的元素。将最后的这几个递增元素逆置，然后从中选取一个比打破递增状态元素大的最小的元素。让他们交换即可。注意边界的考虑。时间复杂度**O(N)**；空间复杂度**O(1)**。[我的代码](Source/nextPermutation.h) 利用了STL中的二分查找。[别人代码](Source/nextPermutation_1.h) 


- - -
- - -
## ------------------leetcode hot 100-----------------

## Q：617.合并二叉树
> * [题目链接](https://leetcode-cn.com/problems/merge-two-binary-trees/)
> * 根据题意，直接同时递归调用两个子树即可。然后处理一下一棵树到达叶子结点的异常情况。时间复杂度为**O(min(M, N))**，空间复杂度为**O(log min(M, N))**。[我的代码](Source/mergeTrees.h)；[其他人代码](Source/mergeTress_1.h)
> * 可以将递归版本修改为非递归版本。

## Q：461.汉明距离
> * [题目链接](https://leetcode-cn.com/problems/hamming-distance/)
> * 根据题意，即找两个数二进制形式相应位上数值不同的次数。先利用异或，然后统计异或结果中有多少个1即可。统计1的个数可以使用右移操作然后与1进行`&`操作。由于整数的位数是固定的，所以最多比较31次。所以时间和空间复杂度均为**O(1)**。[我的代码](Source/hammingDistance.h)
> * 布莱恩.克尼格根算法：当一个数N与N-1进行与操作时，那么最右边的一个1将会被消除。利用此方法，通过异或结果中1的个数。时间和空间复杂度均为**O(1)**。[我的代码](Source/hammingDistance_1.h)


## Q：226.翻转二叉树
> * [题目链接](https://leetcode-cn.com/problems/invert-binary-tree/)
> * 按照题意，将一棵二叉树先序遍历，另一个按“伪后序遍历”，则它们的遍历顺序是对称。这里的后序遍历指的是先遍历当前结点，然后遍历右子树，最后遍历左子树。一遍遍历，一遍建树即可。时间复杂度**O(N)**。空间复杂度**O(N + logN)**。logN是递归栈的深度。[我的代码](Source/invertTree.h)
> * 递归的思想：要想翻转整个二叉树，只需要递归翻转左子树和右子树，然后将左孩子和右孩子交换即可。时间复杂度为**O(N)**，空间复杂度为**O(logN)**。[我的代码](Source/invertTree_1.h)
> * 层序遍历，一种迭代的自顶向下的做法：对于根结点，先入队列；当出队列时，交换结点左右孩子，然后判断左右孩子是否为空，如果不为空则需要入队列。时间复杂度为**O(N)**。空间复杂度为**O(N)**，对于满二叉树，最后一层需要存储N/2个结点。[官方代码](Source/invertTree.java)

## Q：104.二叉树的最大深度
> * [题目链接](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)
> * 递归计算左右子树的高度，然后返回其中较大者加1。时间复杂度**O(N)**，空间复杂度**O(logN)**。[我的代码](Source/maxDepth.h)
> * 层序遍历，每一层即为一个高度。[我的代码](Source/maxDepth_1.h)；[其他人代码](Source/maxDepth_2.h)
> * 当使用迭代版本DFS时，可以使用pair结构，标识每个结点的深度。[其他人代码](Source/maxDepth_3.h)

## Q：206.反转链表
> * [题目链接](https://leetcode-cn.com/problems/reverse-linked-list/)
> * 如果可以使用 **O(N)** 的额外空间复杂度，则使用一个栈，先将所有结点入栈，然后出栈，一一连接就好。时间和空间复杂度均为**O(N)**。
> * 当使用递归反转链表时，递归函数返回已经返回已经反转过的链表的尾节点，然后重新连接一下当前结点和尾节点就好。为了最后返回反转的链表，需要定义一个全局变量，保存反转链表后的头节点。时间和空间复杂度均为**O(N)**。[我的代码](Source/reverseList.h)；[别人的代码](Source/reverseList.java)
> * 当使用迭代方法时，遍历链表，一遍遍历，一遍修改结点指针的指向。时间复杂度**O(N)**，空间复杂度为**O(1)**。[我的代码](Source/reverseList_1.h)
> * 遍历链表，依次将每个结点头插到新链表中。时间复杂度**O(N)**，空间复杂度**O(1)**。[其他人代码](Source/reverseList_2.h)

## Q：136.只出现一次的数字
> * [题目链接](https://leetcode-cn.com/problems/single-number/)
> * 由于只允许线性复杂度，所以想到使用hash，利用`hashset`来实现。由于大部分元素都出现两次，所以遍历数组，第一次遇到元素，将其加入`hashset`；第二次遇到再将其从中删除。这样一次遍历下来，`hashset`中只存在那个只出现一次的元素。然后再遍历一遍数组，判断哪个元素在`hashset`中即可。时间和空间复杂度均为**O(N)**。[我的代码](Source/singleNumber.h)
> * 位操作：任何一个整数，如果将它和0异或，那么将得到它自己；如果将其和自己异或，那么将得到0。并且异或操作满足交换律。所以将数组中所以元素异或，将得到那个只出现一次的元素。时间复杂度为**O(N)**，空间复杂度为**O(1)**。[我的代码](Source/singleNumber_1.h)

## Q：169.多数元素
> * [题目链接](https://leetcode-cn.com/problems/majority-element/)
> * 由于多数元素大于n/2，所以将数组排序后，最中间的元素一定是多数元素。排序使用快排，所以时间复杂度为**O(N*logN)**，空间复杂度为**O(logN)**。[我的代码](Source/majorityEliment.h)
> * 利用哈希表进行计数。最后遍历哈希表，找出其中次数大于N/2的元素。时间复杂度为**O(N)**，空间复杂度为**O(N)**。[官方代码](Source/majorityEliment_1.h)
> * 分治法：如果一个数是一个数组的众数，那么其一定也是数组左半部分或者右半部分的众数。所以递归求出左右子数组的众数，然后将其合并即可。时间复杂度为**O(NlogN)**，空间复杂度为**O(logN)**。[官方代码](Source/majorityEliment_2.h)
> * 摩尔投票法：用一个计数变量和候选变量，计数变量初始化为0，候选变量可以初始化为任意数。然后遍历数组。如果当前变量与候选变量相同，则递增计数变量，否则递减计数变量；如果计数变量为0，则将当前数赋值给候选变量，然后继续以上过程。当遍历完数组时，候选变量即为众数。时间复杂度为**O(N)**，空间复杂度为**O(1)**。[我的代码](Source/majorityElement_3.h)
> * **摩尔投票法的原理**：当一个数重复的次数超过数组长度的二分之一，那么将数组中任意两个不同的数删除后，最终剩下的数就是这个要找的数。
> * 位运算：对于数组上的所有数，因为众数的个数超过数组的二分之一，所以考虑所有整数的每个位上的值。统一所有整数上每个位是否为1。如果是，则最终的众数该位上也为1，否则最终的众数上该位不为1。时间复杂度为**O(N)**，空间复杂度为**O(1)**。[其他人代码](Source/majorityElement_4.h)

## Q：21.合并两个有序链表 <span id="21copy"></span>
> * [链接](#21)

## Q：538.把二叉搜索树转换为累加树
> * [题目链接](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)
> * **反序中序遍历**：对于一个二叉搜索树，右子树上所有结点值比它大，所以先递归处理右子树，然后计算右子树所有元素和，当前结点值加上右子树所有元素和；然后递归处理左子树。时间复杂度为**O(N)**，空间复杂度为**O(logN)**，最坏情况下空间复杂度为**O(N)**。[我的代码](Source/convertBST.h)
> * 利用**Morris遍历**，实现 **O(1)** 的空间复杂度。(自己实现一下)[官方代码](Source/convertBST.java)

## Q：283.移动零
> * [题目链接](https://leetcode-cn.com/problems/move-zeroes/)
> * 根据题意，遍历数组，如果当前元素为0，从下一个位置开始遍历，找到一个非0值与当前元素交换。如果找不到一个任意一个非0值，则说明符合题意了。时间复杂度为**O(N^2)**，空间复杂度为**O(1)**。[我的代码](Source/moveZeroes.h)
> * **双指针法**：对于上面的解决方法，每次查找非0值都是从当前元素的下一个元素查找的，这样做了很多重复的查找。因为从当前元素的下一个到上一次查找返回的第一个非0值之间肯定都是0值，所以为了提高查找效率，应该从上一次查找返回的位置开始查找。时间复杂度为**O(N)**，空间复杂度为**O(1)**。其实也是快排的思想。[我的代码](Source/moveZeroes_1.h)。[官方代码](Source/moveZeroes_2.h)

## Q：448.找到所有数组中消失的数字
> * [题目链接](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)
> * 由于题目要求**O(N)**的时间复杂度和**O(1)**的空间复杂度，所以需要在原数组上做标注。由于所有元素的值都在`1 - N`之间，并且数组长度为`N`，所以遍历数组，当元素值`value`不为`0`值，则先将位置`value-1`位置上的元素记录下来为`tmp`，然后将位置`value-1`上的元素置为`0`，以表示元素`value`出现过；递归处理位置`tmp`上的元素，直到位置`tmp`上的元素为`0`。[我的代码](Source/findDisappearedNumbers.h)
> * leetcode官方案例中，将相应位置置为负数，所以不需要递归处理，感觉简单一点。时间复杂度为**O(N)**，空间复杂度为**O(1)**。[官方代码](Source/findDisappearedNumbers_2.h)
> * 还可以将相应位置上的数+N做标记。
> * 将数值`i+1`放在`i`的位置，最后判断，如果位置`i`处放的不是`i+1`，则说明数组中没有这个数。时间复杂度为**O(N)**，空间复杂度为**O(1)**。[别人的代码](Source/findDisappearedNumbers_3.h)
> * 利用`hashset`，将所有元素都加入`hashset`，然后再从`1 - N`，判断`hashset`中是否存在该元素，如果不存在，则说明未出现。时间和空间复杂度均为**O(N)**。[我的代码](Source/findDisappearedNumbers_1.h)