## Q：对一个数量逐渐增长的数据，迅速找出其中的中位数。
> * 使用一个大根堆和一个小根堆，总的来说，用大根堆存储较小的n/2个数，用小根堆存储较大的n/2个数。当两个堆中整数数量的差值大于2时，将相应的大根堆的堆顶弹出放入小根堆中，或者将相应的小根堆的堆顶弹出放入大根堆。

## Q：排序算法稳定性
> * 可以做到稳定的排序算法：**冒泡排序**、**插入排序**、**归并排序**
> * 无法做到稳定的排序算法：**选择排序**、**快速排序**、**堆排序**

## Q：工程中综合排序算法
> * 当数据样本很低的情况下，使用**插入排序**，因为插入排序常数项很低，样本数据量很小时，速度很快。
> * 当数据样本量很大时，如果数据是内置类型，则使用**快速排序**；因为此时不要求算法是稳定的；如果数据是自定义类型，则使用**归并排序**。在这两个算法的递归过程中，当子问题数据量很小时，直接使用**插入排序**，而不是继续递归。

## Q：排序问题补充
> * 归并排序的额外空间复杂度可以变成**O(1)**，搜索“归并排序 内部缓存法”。
> * 快速排序可以做到稳定，非常难，可以搜索“01 stable sort”。

## Q：桶排序、基数排序、计数排序
> * 非基于比较的排序，与被排序的样本的实际数据状况关系很大
> * 时间复杂度为**O(N)**，额外空间复杂度为**O(N)**。
> * 桶排序分为计数排序和基数排序
> * 桶是一个容器，其实现可以是链表，队列，栈，堆，或者像计数排序一样仅仅是一个数字。
> * 计数排序就是给每个数据进行计数，使用该算法必须要求数据元素的范围有限。

## Q：给定一个数组，求排序之后，相邻两数的最大差值，要求时间复杂度为**O(N)**，且不能使用非基于比较的排序。
> * 如果可以使用基于比较的排序，那么可以直接使用基于比较的排序，然后遍历一遍排序后的数组即可。
> * 正确解法：
>   > * 对于长度为N的数组，先遍历一遍数组，找到数组中的最大值max和最小值min
>   > * 生成N+1个桶，桶用于存储元素，而且每个桶的范围为(max-min)/(N+1)；每个元素落在第几个桶：(x-min)*len/(max-min)；
>   > * 由于总共有N个元素，N+1个桶，所以必有一个桶为空，而且两头的桶不为空，那么空桶两边的桶的最小差值必定大于同一个桶内任何两个元素的差值，所以整个数组的最大差值必定不是由同一个桶内的两个元素产生的。所以只需要计算相邻的两个非空桶中前一个最大值和后一个最小值的差值。
> * [代码](source/MaxGap.h)

## Q：用数组实现固定大小的栈和队列
> *  循环队列：
>   > * 在循环队列中，如果将`front`指向队首元素，`rear`指向队尾元素，那么空队的特征是`front`=`rear`，队满的特征也是`front`=`rear`这将产生二义性。
>   > * 解决方案：
>   >   > * 加标志位，让删除动作使其为1，插入动作使其为0；当`front`=`rear`且标志位为1时，队满；当标志位为0时，队空。
>   >   > * 使用一个计数器来记录队列的实际长度
>   >   > * 人为浪费一个单元，令队满的特征为`(rear+1)%N == front`
> * [栈代码](source/MyStack.h)
> * [循环队列代码](source/MyQueue.h)

## Q：实现一个特殊的栈，除了`pop`和`push`，还可以返回栈中的最小元素`getMin`，可以使用现成的栈结构。
>  * 使用一种双栈结构，一个栈用于存储数据，另一个栈用来存储前n个数的最小值；两个栈的长度相同。
> * [《剑指offer》（包含min函数的栈）](https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tqId=11173&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## Q：如何使用两个队列实现一个栈？
> * 使用两个队列，一个是data队列，另一个是help队列，当入栈时直接将数据加入data队列；当出栈时，先将data队列中前n-1个数据出队列，加入help队列；然后将第n个数出队列；最后将help队列中所有数据出队列加入data队列中。
> * [《leetcode》（用队列实现栈）](https://leetcode-cn.com/problems/implement-stack-using-queues/)

## Q：如何使用两个栈实现一个队列结构？
> * 使用两个栈push栈和pop栈。当加入一个元素时，如果push栈没有满，则直接在push栈加入数据；如果push栈已满，则判断pop栈是否为空，如果为空，则先将push栈中元素出栈然后加入pop栈，再将新元素加入push栈；如果pop不为空，则直接返回错误，无法入栈；当删除弹出一个元素时，如果pop栈不为空，则直接从pop栈弹出元素；如果pop栈为空，则判断push栈是否为空；如果push栈为空，则返回错误，无法弹出元素；如果push栈不为空，则先将push栈弹出并加入pop栈，然后从pop栈弹出。
> * [《剑指offer》（用两个栈实现队列）](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)
