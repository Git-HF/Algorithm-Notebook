## Q：哈希函数（也就是映射函数）
> * 特点：
>   > * 一般来说哈希函数的输入无穷大
>   > * 一般来说哈希函数的输出一定是有穷的
>   > * 相同的输入一定有相同的输出
>   > * 不同的输入，输出可能相同，可能不同
>   > * 哈希函数在大量输入时输出域上是均匀分布的
> * 在某种程度上散列与排序是一对相反操作。排序是将集合中的元素按照某种方式排列在一起，而散列通过计算哈希值打破元素之间原来的关系，使集合中的元素按照散列函数进行排列。

## Q：常见哈希函数构造方法
> * 直接定址法
>   > * 利用一个线性函数将key进行映射，例如：H(key) = a * key + b
> * 除留取余法
>   > * 将关键字对某个数字进行取余，例如：H(key) = key % m
> * 数字分析法
> * 平方取中法
>   > * 计算关键字值的平方，然后取平方值中间几位作为散列地址。
> * 折叠法
>   > * 将关键字分成位数相同的几部分，然后将各部分叠加。
> * 随机数法
>   > * 选择一个随机函数，将关键字的随机函数值作为哈希值。

## Q：哈希冲突的解决方法
> * 链接法：处理冲突简单，无堆积现象。
> * 开放定址法：
>   > * 当发生冲突时，使用某种线性探测技术在散列表中寻找下一个空的位置。根据探测序列不同，又可以分为**线性探查法**、**二次探查法**、**双重散列法**。
>   > * 线性探查法：从发生冲突位置开始，依次向后查找，直到回到发生冲突的位置。
>   > * 二次探查法：从发生冲突位置开始，依次查找1、4、9、16......等位置，直到回到发生冲突的位置。
>   > * 双重哈希

## Q：哈希的应用
> * 哈希表
> * 分布式缓存
>   > 网络环境下的分布式缓存系统一般基于一致性哈希（Consistent hashing）。简单的说，一致性哈希将哈希值取值空间组织成一个虚拟的环，各个服务器与数据关键字K使用相同的哈希函数映射到这个环上，数据会存储在它顺时针“游走”遇到的第一个服务器。可以使每个服务器节点的负载相对均衡，很大程度上避免资源的浪费。  
>   > 在动态分布式缓存系统中，哈希算法的设计是关键点。使用分布更合理的算法可以使得多个服务节点间的负载相对均衡，可以很大程度上避免资源的浪费以及部分服务器过载。使用带虚拟节点的一致性哈希算法，可以有效地降低服务硬件环境变化带来的数据迁移代价和风险，从而使分布式缓存系统更加高效稳定

## Q：哈希表
> * 总的来说，哈希表的增删改查基本都可以达到**O(1)**。
> * 哈希表的经典结构一般会有一个固定容量的桶；当一个输入计算完哈希码以后，然后会对桶个数取模，然后将输入放入相应的桶。当输入数量太多了，可能会引起哈希表扩容。
> * 哈希表（或者哈希函数）通常可以用来解决大数据问题（分流）。

## Q：设计一种结构，有如下三个功能：`insert(key)`，将某个`key`加入到该结构，做到不重复加入；`delete(key)`将结构中的某个`key`移除。`getRandom()`等概率随机返回结构中的任何一个`key`。要求三个方法的时间复杂度都是`O(1)`。
> * 为了完成`insert`和`delete`，只需要使用`hashmap`或者`hashset`就可以了。为了随机返回一个元素，我们需要获得一个随机索引，返回索引所对应的值。可是`key`的值事先是不知道的，没办法使用一个随机函数得出一个`key`，但是一般我们有`rand`函数生成一个随机整数，所以我们可以利用元素加入结构的顺序来做索引，所以引入第二个`hashmap`。总的来说，一个用来存储`size-key`，另一个用来存储`key-size`。
> * 设计一个结构，包含两个`hashmap`和一个`size`，`size`表示当前结构中元素的个数（或者表示加入第几个加入结构）。当添加一个元素时，在一个`hashmap`中添加`key-size`对，并且在另一个`hashmap`中添加`size-key`对，并将size加一。当返回随机元素时，先随机一个`0`到`size-1`的整数，然后返回`size-key`中的`key`。当删除一个元素时，为了保证`size-key`中`size`是连续的，所以先将要删除的元素的与最后一个元素交换，然后删除最后一个元素，将`size-1`，这样就保证了整个结构中的`size`是连续的。

## Q：布隆过滤器（用来查询某个元素是否在集合中）
> * 布隆过滤器流程：
>   > * 布隆过滤器有一个`bit`数组和多个`hash`函数组成。先创建一个需求大小的数组，当加入一个元素时，将元素通过K个相互独立的哈希函数，然后取模，将数组中相应的位都置位；当判断某个元素是否在集合中，将查询的元素通过K个哈希函数，判断相应的所有位是否已经置位。如果是，则该元素可以在集合中，如果有任意一个位未置位，则一定不在该集合中。
> * ***布隆过滤器怎么删除元素？？？***
> * 布隆过滤器有一定失误率，会误判（宁可错杀三千，也不放过一个）。
> * 布隆过滤器数组的长度与样本的数量和所期望的失误率有关，公式为(m = -(n * lnP) / ((ln2)^2)(该单位为比特)。(n是样本量)
> * 确定哈希函数的个数：K = ln2 * n / m
> * 确定了m和K以后，最终的失误率为(1 - e^(-(n*K)/m))^K。
> * 优缺点：占用空间较少，可以实现高效的插入和查询操作，但有一定的失误率。**传统的布隆过滤器不支持删除操作**。

## Q：一致性哈希
> * 虚拟节点
> * 可能会有哈希冲突，但是概率非常小。
> * 容错性和可扩展性。
> * 相对于普通hash函数的优点：
> > * **容错率**：对于普通的`hash`，如果一个服务器出现故障了，那么对应这一台服务器上的数据将没法处理，而一致性哈希会顺着环向下查找另一个可以使用的服务器。
> > * **可扩展性**：当使用普通哈希时，当增加一台服务器时，可能所有服务器上的数据都需要迁移；而使用一致性哈希时，结点的增加和删除只需要重定位环空间的一小部分数据。例如增加一个结点时，只有新增加的结点按逆时针找到的第一个结点之间的数据需要发生变化。
> * 一致性hash算法：[连接](https://juejin.im/post/5ae1476ef265da0b8d419ef2)
