## Q： 一个有M个整数的有序数组A，一个有N个整数的无序数组B，找出B中所有不在A中的整数？
> * 暴力求解，算法复杂度为**O(M*N)**；
> * 对于B中的每一个整数，使用二分查找在A中搜索，复杂度为**O(N*logM)**。
> * 先将B中数组排序，然后使用外排序的方法搜索，复杂度为**O(N*logN)+O(N+M)**。

- - -
## 所有排序算法都默认从小到大排序
- - -
## Q：冒泡排序
> * 每次相邻的两个数比较；每一趟可以将最大的数排好。
> * 时间复杂度：O(N^2)(**与数据状态无关**)，额外空间复杂度：O(1)
> * [代码连接](source/BubbleSort.h)

## Q：选择排序
> * 每一趟选择一个最小的数，然后与第n个数交换，每次可以将最小的数排好。
> * 时间复杂度：O(N^2)(**与数据状态无关**)，额外空间复杂度：O(1)
> * [代码链接](source/SelectSort.h)
> * **尽量将>=或者<=的形式换成>或者<的形式**。

## Q：插入排序
> * 每一趟假设前n个数已经排好了，然后插入第n+1个数。
> * 时间复杂度：**与数据状态有关**，最好O(N)，最差O(N^2)，额外空间复杂度：O(1)
> * [代码链接](source/InsertSort.h)
> * (位运算交换两个变量？？？)。

## Q：对数器
> * 产生一个随机数组，数组长度和值都是随机的；[代码](source/GenerateRandomArray.h)
> * 准备一个绝对正确的，但复杂度可能比较差的算法；
> * 验证自己的方法结果和绝对正确的方法的结果是否相同。

## Q：递归算法时间复杂度估计
> * 如果**T(N)=aT(N/b) + O(n^d)**，则
>   > * (1) 如果**log(b, a) > d**，则**T(N)=O(N^log(b, a))**
>   > * (2) 如果**log(b, a) = d**，则**T(N)=O(N^d * logN)**
>   > * (3) 如果**log(b, a) < d**，则**T(N)=O(N^d)**

## Q：归并排序
> * 先将左边的数组排序，再将右边的数组排序，最后利用外排序的方法。
> * 时间复杂度：**O(N*logN)**，空间复杂度：**O(N)**。
> * [代码链接](source/MergeSort.h)
> * **整数除以二可以用右移操作来代替，加速计算**。
> * 使用**L+**(**R-L**)**/2**来代替(**L+R**)**/2**可以防止溢出。

## Q：小和问题与逆序对问题
> * **小和问题**描述：
>   > 一个数组中，每一个数比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和
> * **逆序对问题**描述
>   > 如果一个数组中，前面的整数大于后面的整数，则称它们是一对逆序对。打印一个数组中所有逆序对。
> * 这两个问题都可以使用归并排序，在子过程合并过程中，利用组内的有序信息，可以减少不必要的比较操作，从而加速算法。
> * [小和问题代码](source/SmallSum.h)
