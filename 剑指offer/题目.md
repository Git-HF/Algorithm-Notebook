## Q：包含min函数的栈
> * 使用一个辅助栈，用来存储当插入或者删除一个数后，剩下元素的最小值；[***代码***](source/MinStack.h)
> * 使用一个辅助数组，当插入一个数时，如果插入的数比不大于minStack栈顶元素，则向minStack插入新元素，否则不插入；当删除一个数时，如果删除的数与当前minStack的栈顶元素相等，则minStack也删除栈顶元素。[***代码***](source/MinStack_1.h)
> * （**该方法有问题，当差值大于整数所能表示的范围，该方法错误**）压缩还原法：只需要一个栈stack、一个保存当前最小值的变量min和当前的top值；当入栈时，先将value-min入栈；如果value-min小于零，则更新min；否则不更新；最后更新top；当出栈时，先判断栈顶元素是否小于零。如果是，则更新min，否则不更新。栈中元素出栈。此时返回top值，并且更新top；如果此时栈顶元素小于零，则top=min；否则top=min+栈顶元素。

## Q：用两个栈实现队列
> * [代码](source/TwoStackToQueue.h)（如果栈的大小有限制，则`push`都应该考虑栈`stack1`栈满的情况）

## Q：顺时针打印矩阵
> * 分成打印，先打印最外层，，然后逐渐向内收缩。注意只有一行或者只有一列的边界处理；此代码中，将只有一行和只有一列单独拿出来考虑了。 **(在矩阵中，最好使用行(row)和列(colume)的标志，而不适用x、y的标志。因为坐标系中的x对应列，y对应行，这样元素就得表示成matrix[y][x]，这样看起来很不符合习惯。)**[代码](source/SpiralOrder.h)
> * 未将只有一行和只有一列单独考虑，而是在从右向左打印和从下到上打印时，防止重复打印。和上一个方法的区别就是边界处理的方式不同[代码](source/SpiralOrder_1.h)
> * 每一次将矩阵第一行删除，然后将矩阵逆时针旋转90度，直到矩阵中没有元素了。这个额外空间复杂度较高。[代码](source/SpiralOrder_2.h)

