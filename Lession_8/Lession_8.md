## Q：对于一个长度为N金条，把他切成两半的代价为N。现在给定一个数组，数组中所有元素之和表示金条一开始的长度，要求把这个金条切成数组中每个元素的长度，求产生代价最小的切法。
> * 典型的哈夫码编码问题，哈夫曼编码也是一个贪心策略。
> * 对于数组中的元素，先加入小根堆中，然后每次拿出两个最小的数，将他们相加以后再放回小根堆，直到堆中只有一个元素为止。这个路径反过来就是代价最小的切法。

## Q：给定两个数组`cost`和`profit`，分别表示做一个项目需要花费的资金和做完项目的可以获得的利润（已经除去了本金），现在给定一个初始资金`W`，和最多可以做`K`个项目，求可以获得的最大利润。
> * 贪心策略。
> * 先创建一个小根堆，按照每个项目花费的资金排序；然后将小根堆中花费资金小于本金的所有项目弹出，加入一个大根堆，按照每个项目获得的利润排序。然后每次弹出大根堆中堆顶元素，因为这是目前可以做的利润最大的项目，更新本金，然后继续判断小根堆中是否有需要弹出的元素。持续这个循环直到小根堆为空（目前的本金已经不够所有项目了）或者已经做了`K`个项目。
> * [《leetcode》（502.IPO）](https://leetcode-cn.com/problems/ipo/)

## Q：给定一个表示事件的数组，每个事件都有一个开始时间`start`和结束时间`end`。同一时间只能做一件事，求怎么安排事件流程可以是做的事件数量最多。
> * 贪心策略
> * 先将每个事件按照结束时间`end`排序，然后从第一个事件开始做，初始化当前时间为0。当做完一个事件后，判断下一个事件的开始时间`start`是否早于当前时间，如果是，则跳过，继续判断下一个事件；如果不是，则执行该事件，同时更新当前时间。

## Q：暴力递归和动态规划
> * 暴力递归：
>   > * 把问题转化为规模缩小了的同类问题的子问题
>   > * 有明确的不需要继续进行递归的条件则终止（**basecase**）
>   > * 有当得到了子问题的结果之后的决策过程
>   > * 不记录每一个子问题的解
> * **求n!** 问题和**汉诺塔**问题都是暴力递归问题。
> * 动态规划：
>   > * 状态的定义
>   > * 转移方程
>   > * basecase

## Q：给定一个字符串数组，打印所有子字符串。
> * 可以使用递归算法
> * [《leetcode》（78.子集）](https://leetcode-cn.com/problems/subsets/)

## Q：给定一个字符串，打印字符串所有可能的全排列
> * [《leetcode》(46.全排列)](https://leetcode-cn.com/problems/permutations/)

## Q：给定一个二维数组，其中每个数都是正数，要求从左上角走到右下角，每一步只能向右或者向下。求沿途经过的数字之和最小的路径。
> * 对于任何一个位置，通往右下角只有两条路径，要么往下，要么往右。递归求解右边和下边节点的最小路径，那么取其中的最小值，然后加上自身，就是到当前位置的最小路径。
> * 动态规划思想需要暂存计算过的路径的值，可变参数为节点的行索引`i`和列索引`j`。
> * [《leetcode》（64.最小路径和）](https://leetcode-cn.com/problems/minimum-path-sum/)

## Q：给定一个数组arr和一个整数aim。如果可以任意选择arr中的数字，能不能累加得到aim，返回true或者false。
> * 有点像求字符串的所有子字符串，暴力递归即可。
> * 对于数组中第`i`个数字，前面`i-1`个数字形成的和为`sum`，那么第`i`个元素既可以加入`sum`，也可以不加入`sum`。递归求解这个过程。
> * 动态规划需要暂存一些值，可变参数为位置`i`和`sum`。

## Q：注意回溯和递归的区别和练习，回溯的一般框架图